#+STARTUP: hideblocks
* Preamble
  #+NAME: Preamble
  #+BEGIN_SRC R :results silent :session MasArThesisRConsole
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/MasAr_Thesis.tex
    rm(list = ls())
    setwd(dir = "~/laptop02_MasAr")
    kDataDir <- "Data/"
    ## Load data set.
    kBaseFileVersion <- "5.3"
    kBaseFileName <- paste0(kDataDir, "gmax_merged_", kBaseFileVersion, ".RData")
    kgmaxObjects <- load(file = kBaseFileName, verbose = TRUE)
    ## Set dimensions of PDF device.
    kCmToInch <- 1 / 2.54
    kMmToInch <- 1 / 25.4
    kMarginTop <- 20  ## For margins see "~/Uni/Formatvorlagen/LaTeX/settings.tex", block "geometry".
    kMarginOuter <- kMarginTop
    kMarginBottom <- kMarginTop
    kMarginInner <- 30
    kPdfWidthA4Portrait <- (210 - kMarginInner - kMarginOuter) * kMmToInch
    kPdfHeightA4Portrait <- (297 - kMarginTop - kMarginBottom) * kMmToInch
    kPdfWidthA4Landscape <- (297 - kMarginTop - kMarginBottom) * kMmToInch
    kPdfHeightA4Landscape <- (210 - kMarginInner - kMarginOuter) * kMmToInch
    kPdfWidth1by1 <- (210 - 30 - 20) * 0.5 * kMmToInch
    kPdfHeight1by1 <- kPdfWidth1by1
    kPdfWidth1by2 <- 2 * kPdfWidth1by1
    kPdfHeight1by2 <- kPdfHeight1by1
    kPdfWidth2by2 <- kPdfWidth1by2
    kPdfHeight2by2 <- kPdfWidth2by2
    ## Set point size for PDF device.
    kPdfPointSize <- 9
    ## Set font family for PDF device.
    kPdfFamily <- "Times"
    ## Set standard point character for plots.
    kPointCharacter <- 20
    ## Set standard line settings for plots.
    kLineWidth <- 1
    kLineType <- "solid"
    ## Set a distinct color for each species to use in all multi-species plots. Colors are taken from NiedersÃ¤chsische Landesforsten (2011), fig. 3.
    kSpeciesColors <- list("beech" = "#ee7f00",
		       "spruce" = "#4066aa")
    ## Set plot grid properties.
    kGridLineType <- "dashed"
    kGridLineCol <- "gray"
    kGridLineWidth <- 0.5
    ## Set background color for plot legends.
    kLegendBg <- "gray"
    ## Set vectors of species names.
    kSpeciesNames <- c("beech", "spruce")
    kSpeciesNamesCapitalized <- c("Beech", "Spruce")
    ## Set destination directory for output.
    kOutputSubdir <- "R/Output/Thesis/"
    ## Set destination directory for graphics.
    kGraphicsSubdir <- "Graphics/Thesis/"
    ## If nonexistent, create all required directories.
    system2(command = "mkdir",
	  args = paste0("-p ", c(kGraphicsSubdir, kOutputSubdir)))
    objects.at.script.start <- c(ls(), "objects.at.script.start")  ## Required for cleaning up workspace.
  #+END_SRC
* log(N)-log(D)-plots before/after data selection
  #+NAME: log(N)-log(D)-plots before/after data selection
  #+BEGIN_SRC R :results silent :var input=Preamble :session MasArThesisRConsole
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/Data_Selection.tex
    ## This creates 4 plots in one file in a 2-by-2 layout (one row per species, one column per data selection state), showing the effect of the data selection mechanism.
    ## Plotting preamble.
    kPlotMargins <- c(3.5, 3.5, 1, 1)
    kPlotMgp <- c(2, 1, 0)
    kXLab <- expression(paste("log(", italic("D"), ")"))
    kYLab <- expression(paste("log(", italic("N"), ")"))
    kXMin <- list("beech" = 0.8,
	        "spruce" = 0.8)
    kXMax <- list("beech" = 1.8,
	        "spruce" = 1.8)
    kYMin <- list("beech" = 1.6,
	        "spruce" = 2.4 * 0.9)
    kYMax <- list("beech" = 3.6,
	        "spruce" = 3.6)
    kPlotLayout <- 1:4
    kUpperThresholdLineType <- "dashed"
    kLowerThresholdLineType <- "solid"
    kThresholdLinesFrom <- 0
    kThresholdLinesTo <- 10
    kThresholdLinesCol <- "black"
    ## Loop over all species names.
    ## for (cur.species.name in kSpeciesNames) {
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   ## cur.species.name,
		   ## "_logN_logD_Plot_before_after_data_selection.pdf")
		   "logN_logD_Plots_before_after_data_selection.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidth2by2,
        height = kPdfHeight2by2,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot margins.
    par("mar" = kPlotMargins)
    ## Set plot layout to 2-by-2.
    layout(mat = matrix(data = kPlotLayout,
		    ## nrow = 1,
		    nrow = 2,
		    ncol = 2,
		    ## byrow = FALSE))
		    byrow = TRUE))
    ## Loop over all plot numbers.
    for (cur.plot.nr in kPlotLayout) {
        ## Set current species name ("beech" for plots number 1 and 2, "spruce" for plots number 3 and 4).
        cur.species.name <- ifelse(test = cur.plot.nr <= 2,
			     yes = "beech",
			     no = "spruce")
        ## Extract x- and y-limits for current species.
        cur.xmin <- as.numeric(x = kXMin[names(x = kXMin) == cur.species.name])
        cur.xmax <- as.numeric(x = kXMax[names(x = kXMax) == cur.species.name])
        cur.ymin <- as.numeric(x = kYMin[names(x = kYMin) == cur.species.name])
        cur.ymax <- as.numeric(x = kYMax[names(x = kYMax) == cur.species.name])
        ## Set point and line color for current species.
        cur.point.line.col <- as.character(x = kSpeciesColors[names(x = kSpeciesColors) == cur.species.name])
        ## Set data frame version for current plot number ("1.0" for plots number 1 and 3, "1.8" for plots number 2 and 4).
        cur.data.frame.version <- ifelse(test = cur.plot.nr %% 2 != 0,
				 yes = "1.0",
				 no = "1.8")
        ## Get data frame for current species and plot number.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.", cur.data.frame.version))
        ## Select column specifier for current plot ("A" for plot number 1, "B" for plot number 2, "" for plots number 3 and 4).
        if (cur.plot.nr <=2) {
	  cur.plot.main <- ifelse(test = cur.plot.nr %% 2 != 0,
			      yes = "A",
			      no = "B")
        } else {
	  cur.plot.main <- ""
        }
        ## Set x-axis label for current plot ("" for plots number 1 and 2, kXLab for plots number 3 and 4).
        cur.xlab <- ifelse(test = cur.plot.nr <= 2,
		       yes = "",
		       no = kXLab)
        ## Set y-axis label for current plot (kYLab for plots number 1 and 3, "" for plots number 2 and 4).
        cur.ylab <- ifelse(test = cur.plot.nr %% 2 != 0,
		       yes = kYLab,
		       no = "")
        ## Initiate legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        legend.lwd <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
        ## Create empty plot.
        plot(x = 0,
	   type = "n",
	   xlim = c(cur.xmin, cur.xmax),
	   ylim = c(cur.ymin, cur.ymax),
	   ## xlab = kXLab,
	   xlab = cur.xlab,
	   ## ylab = kYLab,
	   ylab = cur.ylab,
	   xaxs = "i",
	   yaxs = "i",
	   mgp = kPlotMgp,
	   main = cur.plot.main,
	   panel.first = abline(v = seq(from = 0,
				  to = 2,
				  by = 0.2),
			    h = seq(from = 0,
				  to = 4,
				  by = 0.2),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Define function for calculating the lines representing the slope thresholds.
        slope.threshold.func <- function(s, x, k) {
	  res <- s * x + k
	  return(res)
        }
        ## Add line for upper slope threshold to plot.
        cur.species.upper.slope.threshold <- ifelse(test = cur.species.name == "beech",
					  yes = -0.9,
					  no = -0.65)
        cur.species.threshold.func.upper.intercept <- cur.ymax - cur.species.upper.slope.threshold * cur.xmin
        curve(expr = slope.threshold.func(s = cur.species.upper.slope.threshold,
				  x,
				  k = cur.species.threshold.func.upper.intercept),
	    from = kThresholdLinesFrom,
	    to = kThresholdLinesTo,
	    lty = kUpperThresholdLineType,
	    lwd = kLineWidth,
	    col = kThresholdLinesCol,
	    add = TRUE)
        ## Update legend components.
        legend.legend <- c(legend.legend, paste0("upper slope threshold ", cur.species.name))
        legend.pch <- c(legend.pch, NA)
        legend.lty <- c(legend.lty, kUpperThresholdLineType)
        legend.lwd <- c(legend.lwd, kLineWidth)
        legend.col <- c(legend.col, kThresholdLinesCol)
        ## Add line for lower slope threshold to plot.
        cur.species.lower.slope.threshold <- ifelse(test = cur.species.name == "beech",
					  yes = -2.91,
					  no = -2.82)
        cur.species.threshold.func.lower.intercept <- cur.ymax - cur.species.lower.slope.threshold * cur.xmin
        curve(expr = slope.threshold.func(s = cur.species.lower.slope.threshold,
				  x,
				  k = cur.species.threshold.func.lower.intercept),
	    from = kThresholdLinesFrom,
	    to = kThresholdLinesTo,
	    lty = kLowerThresholdLineType,
	    lwd = kLineWidth,
	    col = kThresholdLinesCol,
	    add = TRUE)
        ## Update legend components.
        legend.legend <- c(legend.legend,  paste0("lower slope threshold ", cur.species.name))
        legend.pch <- c(legend.pch, NA)
        legend.lty <- c(legend.lty, kLowerThresholdLineType)
        legend.lwd <- c(legend.lwd, kLineWidth)
        legend.col <- c(legend.col, kThresholdLinesCol)
        ## Loop over all "edvid"s.
        for (cur.edvid.name in levels(x = cur.data.frame[["edvid"]])) {
	  ## Extract x-values for current "edvid".
	  cur.x.values <- cur.data.frame[["log.dg"]][cur.data.frame[["edvid"]] == cur.edvid.name]
	  ## Extract y-values for current "edvid".
	  cur.y.values <- cur.data.frame[["log.nha"]][cur.data.frame[["edvid"]] == cur.edvid.name]
	  ## Add points to plot per "edvid", with distinct colors per species.
	  points(x = cur.x.values,
	         y = cur.y.values,
	         type = "p",
	         pch = kPointCharacter,
	         lty = kLineType,
	         col = cur.point.line.col)
	  ## Add lines to plot per "edvid", with distinct colors per species.
	  lines(x = cur.x.values,
	        y = cur.y.values,
	        lty = kLineType,
	        lwd = kLineWidth,
	        col = cur.point.line.col)
        }
        ## Update legend components.
        legend.legend <- c(legend.legend, paste0("observations ", cur.species.name))
        legend.pch <- c(legend.pch, kPointCharacter)
        legend.lty <- c(legend.lty, kLineType)
        legend.lwd <- c(legend.lwd, kLineWidth)
        legend.col <- c(legend.col, cur.point.line.col)
        ## Add legend.
        legend(x = "bottomleft",
	     legend = legend.legend,
	     col = legend.col,
	     lty = legend.lty,
	     pch = legend.pch,
	     lwd = legend.lwd,
	     bg = "gray")
        ## Reset legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        legend.lwd <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
    }
    ## Turn off graphics device.
    graphics.off()
    ## }
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* Location of sample plots
  #+NAME: Location of sample plots
  #+BEGIN_SRC R :results silent :var input=Preamble :session MasArThesisRConsole
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/Data_Description.tex
    ## This block creates 2 plots (one per species) in one file in a 1-by-2 layout, showing the locations of the sample plots on a map of Germany.
    ## Plotting preamble.
    kPlotMargins <- c(0.5, 0.5, 0.5, 0.5)
    kPlotLayout <- 1:2
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "Locations_Sample_Plots.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidth1by2,
        height = kPdfHeight1by2,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout to 1-by-2.
    layout(mat = matrix(data = kPlotLayout,
		    nrow = 1,
		    ncol = 2,
		    byrow = FALSE))
    ## Set plot margins.
    par("mar" = kPlotMargins)
    ## Initiate legend components.
    legend.legend <- vector(mode = "character")
    legend.pch <- vector(mode = "numeric")
    legend.col <- vector(mode = "character")
    ## Loop over all plot numbers.
    for (cur.plot.nr in kPlotLayout) {
        ## Set current species name ("beech" for plot number 1, "spruce" for plot number 2).
        cur.species.name <- ifelse(test = cur.plot.nr == 1,
			     yes = "beech",
			     no = "spruce")
        ## Set point and line color for current species.
        cur.point.line.col <- as.character(x = kSpeciesColors[names(x = kSpeciesColors) == cur.species.name])
        ## Get data frame for current species and plot number.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Condense "cur.data.frame" to the unique values of columns "edvid", "EAST.UTM", and "NORTH.UTM".
        cur.data.frame <- unique(x = cur.data.frame[, c("edvid", "EAST.UTM", "NORTH.UTM")])
        ## Extract easting and northing.
        easting <- cur.data.frame[["EAST.UTM"]]
        northing <- cur.data.frame[["NORTH.UTM"]]
        ## Calculate plot axis limits.
        x.lim.low <- range(easting, na.rm = TRUE)[1]
        x.lim.high <- range(easting, na.rm = TRUE)[2]
        y.lim.low <- range(northing, na.rm = TRUE)[1]
        y.lim.high <- range(northing, na.rm = TRUE)[2]
        x.lim <- c(x.lim.low, x.lim.high)
        y.lim <- c(y.lim.low, y.lim.high)
        ## Plot national and federal state boundaries.
        library("sp")
        plot(x = bld_utm,
	   add = FALSE,
	   lwd = kLineWidth)
        ## Add points at sample plot locations to plot.
        points(x = easting,
	     y = northing,
	     xlab = "Easting",
	     ylab = "Northing",
	     col = cur.point.line.col,
	     pch = kPointCharacter)
        ## Draw box around plot.
        box(bty = "o")
        ## Update legend components.
        legend.legend <- c(legend.legend, paste0("sample plots ", cur.species.name))
        legend.pch <- c(legend.pch, kPointCharacter)
        legend.col <- c(legend.col, cur.point.line.col)
        ## Add legend.
        legend(x = "bottomright",
	     legend = legend.legend,
	     pch = legend.pch,
	     col = legend.col,
	     bg = "gray")
        ## Reset legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* Geographic properties of sample plots
  #+NAME: Geographic properties of sample plots
  #+BEGIN_SRC R :results silent :var input=Preamble :session MasArThesisRConsole
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/Data_Description.tex
    ## Preamble.
    ## Set vector of names of similar functions needed in this block.
    kFunctionNames <- c("min", "mean", "median", "max")
    ## Set vector of columns on which the functions mentioned in "kFunctionNames" should be applied.
    kColumnNames <- c("EAST.UTM", "NORTH.UTM", "hnn.neu")
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Initiate "cur.species.results.df".
        cur.species.results.df <- data.frame(kFunctionNames,
				     vector(mode = "numeric", length = length(x = kFunctionNames)),
				     vector(mode = "numeric", length = length(x = kFunctionNames)),
				     vector(mode = "numeric", length = length(x = kFunctionNames)),
				     vector(mode = "numeric", length = length(x = kFunctionNames)))
        colnames(x = cur.species.results.df) <- c("Function.name", kColumnNames, "n")
        ## Get data frame for current species.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Make data frame unique with respect to columns "EAST.UTM", "NORTH.UTM", "hnn.neu", and"edvid".
        cur.data.frame.unique <- unique(x = cur.data.frame[, c(kColumnNames, "edvid")])
        ## Calculate minimum, median, mean, and maximum of columns "EAST.UTM", "NORTH.UTM", and "hnn.neu" and total number of sample plots.
        for (cur.column.name in kColumnNames) {
	  for (cur.function.name in kFunctionNames) {
	      cur.function <- get(x = cur.function.name)
	      ## cur.column.function.result <- cur.function(cur.data.frame.unique[[cur.column.name]],
	      ## na.rm = TRUE)
	      cur.species.results.df[cur.species.results.df[["Function.name"]] == cur.function.name,
			         c(kColumnNames, "n")] <- round(x = c(apply(X = cur.data.frame.unique[, kColumnNames],
							  MARGIN = 2,
							  FUN = cur.function.name,
							  "na.rm" = TRUE),
							  cur.function(length(cur.data.frame.unique[["edvid"]]))),
							digits = 1)
	  }}
        ## Store printing of "cur.species.results.df" in "cur.output", while left justifying output.
        cur.output <- capture.output(print(x = format(x = cur.species.results.df,
					    justify="left",
					    scientific = FALSE),
				   row.names = TRUE))
        ## Output results to file.
        cat(cur.output,
	  file = paste0(kOutputSubdir, "geographic_properties_summary_", cur.species.name, ".txt"),
	  sep = "\n",
	  fill = FALSE)
    }
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* Altitude of sample plots
  #+NAME: Altitude of sample plots
  #+BEGIN_SRC R :results silent :var input=Preamble :session MasArThesisRConsole
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/Data_Description.tex
    ## Plotting preamble.
    kPlotMargins <- c(3, 3, 0.5, 0.75)
    kPlotMgp <- c(2, 1, 0)
    kXValues <- seq(from = 1, to = 2, by = 0.5)
    kXMin <- min(kXValues)
    kXMax <- max(kXValues)
    kYMin <- min(bart.beech.clean.1.8[["hnn.neu"]],
	       bart.spruce.clean.1.8[["hnn.neu"]],
	       na.rm = TRUE)
    kYMax <- round(x = max(bart.beech.clean.1.8[["hnn.neu"]],
		       bart.spruce.clean.1.8[["hnn.neu"]],
		       na.rm = TRUE),
	         digits = -2)
    kYAxisTicks <- seq(from = 0,
		   to = kYMax,
		   by = 100)
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "Altitude_Sample_Plots.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidth1by1,
        height = kPdfHeight1by1,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot margins.
    par("mar" = kPlotMargins)
    ## Create empty plot.
    plot(x = kXValues,
         xlim = c(kXMin, kXMax),
         ylim = c(kYMin, kYMax),
         xlab = "Species",
         ylab = "Altitude above sea level [m]",
         mgp = kPlotMgp,
         type = "n",
         axes = FALSE,
         panel.first = abline(h = kYAxisTicks,
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			col = kGridLineCol))
    axis(side = 1,
         labels = kSpeciesNamesCapitalized,
         at = c(1, 2))
    axis(side = 2,
         labels = TRUE,
         at = seq(from = kYAxisTicks[1],
	        to = kYAxisTicks[length(x = kYAxisTicks)],
	        by = 200))
    ## Draw box around plot.
    box(bty = "o")
    ## Initiate legend components.
    legend.legend <- vector(mode = "character")
    legend.col <- vector(mode = "character")
    legend.pch <- vector(mode = "numeric")
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get point color for current species.
        cur.point.color <- kSpeciesColors[[cur.species.name]]
        ## Get data frame for current species.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Make data frame unique with respect to columns "edvid" and "hnn.neu".
        cur.data.frame.unique <- unique(x = cur.data.frame[, c("edvid", "hnn.neu")])
        ## Add points to plot.
        points(x = rep(x = which(x = kSpeciesNames == cur.species.name), times = length(x = cur.data.frame.unique[["hnn.neu"]])),
	     y = cur.data.frame.unique[["hnn.neu"]],
	     col = cur.point.color,
	     pch = kPointCharacter)
        ## Update legend components.
        legend.legend <- c(legend.legend, paste0("sample plots ", cur.species.name))
        legend.col <- c(legend.col, cur.point.color)
        legend.pch <- c(legend.pch, kPointCharacter)
    }
    ## Add legend.
    legend(x = "topleft",
	 legend = legend.legend,
	 pch = legend.pch,
	 col = legend.col,
	 bg = kLegendBg)
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* Yield class classification of training data
** General procedure:
   1. Set SI.h100 values per yield class based on Schober (1995) (moderate thinning).
   2. Generate a sequence of SI.h100 values from the worst yield class to the best yield class needed to cover the observed range of SI.h100 values, with a distance of 0.1 between sequence elements.
   3. Generate a color palette based on the result of 2.
   4. Map the observed SI.h100 values to the corresponding color of the color palette from 3. for plotting.
   5. Map the SI.h100 value of each yield class to the corresponding color of the color palette from 3. for the legend.
** R Code
   #+NAME: Yield class classification of training data
   #+BEGIN_SRC R :results silent :var input=Preamble :session MasArThesisRConsole
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/Data_Description.tex
     ## Plotting preamble.
     kPlotMargins <- c(3, 3, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kLegendX <- "bottomright"
     kXLim <- c(0, 160)
     kYLim <- c(0, 40)
     ## Define color palette generating function.
     kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
     ## Set best yield class level for which to interpolate SI.h100 values
     kBestYieldClassLevel <- -2
     ## Turn off graphics device.
     graphics.off()
     ## Create file name.
     file.name <-paste0(kGraphicsSubdir,
		    "Training_Data_Yield_Class_Classification.pdf")
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = file.name,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.90,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over all species names.
     for (cur.species.name in kSpeciesNames) {
     ## for (cur.species.name in "spruce") {  ## TESTING
         ## Get data frame for current species.
         bart.cur.species.clean.1.8 <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
         ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
         SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
					"SI.h100" = NA)
         ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
         if (cur.species.name == "beech") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
         }
         if (cur.species.name == "spruce") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
         }
         ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
         for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	   SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	   SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
         }
         ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
         SI.h100.min <- min(bart.cur.species.clean.1.8[["SI.h100"]],
		        na.rm = TRUE)
         SI.h100.max <- max(bart.cur.species.clean.1.8[["SI.h100"]],
		        na.rm = TRUE)
         index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
         index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
         ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
         SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				   to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				   by = 0.1),
			     digits = 1)
         ## Generate a color palette of the same length as "SI.h100.sequence".
         cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Create empty plot.
         plot(x = bart.cur.species.clean.1.8[["alt"]],
	    type = "n",
	    xlim = kXLim,
	    ylim = kYLim,
	    xlab = "stand age [a]",
	    ylab = expression(italic("h")[100]*" [m]"),,
	    main = kSpeciesNamesCapitalized[grep(pattern = cur.species.name,
					 x = kSpeciesNamesCapitalized,
					 ignore.case = TRUE)],
	    mgp = kPlotMgp,
	    xaxs = "i",
	    yaxs = "i",
	    panel.first = abline(v = seq(from = kXLim[1],
				   to = kXLim[2],
				   by = 10),
			     h  = seq(from = kYLim[1],
				    to = kYLim[2],
				    by = 10),
			     lty = kGridLineType,
			     lwd = kGridLineWidth,
			     col = kGridLineCol))
         ## Loop over all evdids.
         for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	   ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	   edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			      subset = edvid == cur.edvid)
	   ## Add lines for observations belonging to current edvid.
	   lines(x =edvid.subset[["alt"]],
	         y = edvid.subset[["h100"]],
	         lwd = kLineWidth,
	         lty = kLineType)
         }
         ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
         for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	   ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	   edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			      subset = edvid == cur.edvid)
	   ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	   SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
					table = SI.h100.sequence)
	   ## Add points to plot.
	   points(x = edvid.subset[["alt"]],
		y = edvid.subset[["h100"]],
		col = cur.species.color.palette[SI.h100.rounded.color.index],
		pch = kPointCharacter)
         }
         ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
         SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						       digits = 1),
				      table = SI.h100.sequence)
         ## Add legend.
         legend.legend <- c(paste0("yield class ",
			     SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
         legend.col <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
         legend.pch <- kPointCharacter
         legend(x = kLegendX,
	      legend = legend.legend,
	      col = legend.col,
	      pch = legend.pch,
	      bg = kLegendBg)
     }
     ## Turn off graphics device.
     graphics.off()
   #+END_SRC
* Number of sample plots and observations
  #+NAME: Number of sample plots and observations
  #+BEGIN_SRC R :results silent :var input=Preamble :session MasArThesisRConsole
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/Data_Description.tex
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get data frame for current species.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Create a subset with only columns "edvid", "h100.EKL.I", and "SI.h100.diff.EKL.I".
        cur.data.frame <- subset(x = cur.data.frame, select = c("edvid", "h100.EKL.I", "SI.h100.diff.EKL.I"))
        ## Count observations per edvid.
        obs.per.edvid <- table(cur.data.frame[["edvid"]])
        ## Store results in data frame.
        cur.species.results.df <- data.frame("edvid" = names(x = obs.per.edvid),
				     "observations.count" = as.numeric(x = obs.per.edvid),
				     stringsAsFactors = FALSE)
        ## Calculate sum of each column.
        cur.species.results.df <- rbind(cur.species.results.df,
				data.frame("edvid" = c(as.character(x = nrow(x = cur.species.results.df)),
						   NA,
						   NA,
						   NA,
						   NA),
					 "observations.count" = c(sum(cur.species.results.df[["observations.count"]]),
							      min(cur.species.results.df[["observations.count"]]),
							      mean(cur.species.results.df[["observations.count"]]),
							      median(cur.species.results.df[["observations.count"]]),
							      max(cur.species.results.df[["observations.count"]]))
					 ))
        ## Set rownames.
        rownames(x = cur.species.results.df) <- c(rownames(x = cur.species.results.df)[1:(length(x = rownames(x = cur.species.results.df)) - 5)],
					"total",
					"min",
					"mean",
					"median",
					"max")
        ## Round column "observations.count" to 1 decimal digit.
        cur.species.results.df[["observations.count"]] <- round(x = cur.species.results.df[["observations.count"]],
						    digits = 1)
        ## Store printing of "cur.species.results.df" in "cur.output", while left justifying output.
        cur.output <- capture.output(print(x = format(x = cur.species.results.df,
					    justify="left",
					    scientific = FALSE),
				   row.names = TRUE))
        ## Output results to file.
        cat(cur.output,
	  file = paste0(kOutputSubdir, "observations_count_per_edvid_", cur.species.name, ".txt"),
	  sep = "\n",
	  fill = FALSE)
    }
  #+END_SRC
* Age and top height range
  #+NAME: Age and top height range
  #+BEGIN_SRC R :results silent :var input=Preamble :session MasArThesisRConsole
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/Data_Description.tex
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get data frame for current species.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Extract age range.
        age.min <- min(cur.data.frame[["alt"]])
        age.max <- max(cur.data.frame[["alt"]])
        ## Extract top height range.
        h100.min <- min(cur.data.frame[["h100"]])
        h100.max <- max(cur.data.frame[["h100"]])
        ## Store results in data frame.
        cur.species.results.df <- data.frame("statistic" = c("min", "max"),
				     "age" = c(age.min, age.max),
				     "h100" = c(h100.min, h100.max))
        ## Store printing of "cur.species.results.df" in "cur.output", while left justifying output.
        cur.output <- capture.output(print(x = format(x = cur.species.results.df,
					    justify="left",
					    scientific = FALSE),
				   row.names = TRUE))
        ## Output results to file.
        cat(cur.output,
	  file = paste0(kOutputSubdir, "min_max_age_and_top_height_", cur.species.name, ".txt"),
	  sep = "\n",
	  fill = FALSE)
    }
  #+END_SRC
* File local variables
# Local Variables:
# End:

