#+STARTUP: hideblocks
* Preamble
  #+NAME: Preamble
  #+BEGIN_SRC R :results silent :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/MasAr_Thesis.tex
    rm(list = ls())
    setwd(dir = "~/laptop02_MasAr")
    kDataDir <- "Data/"
    ## Load data set.
    kBaseFileVersion <- "5.4"
    kBaseFileName <- paste0(kDataDir, "gmax_merged_", kBaseFileVersion, ".RData")
    kgmaxObjects <- load(file = kBaseFileName, verbose = TRUE)
    ## Set dimensions of PDF device.
    kCmToInch <- 1 / 2.54
    kMmToInch <- 1 / 25.4
    kMarginTop <- 20  ## For margins see "~/Uni/Formatvorlagen/LaTeX/settings.tex", block "geometry".
    kMarginOuter <- kMarginTop
    kMarginBottom <- kMarginTop
    kMarginInner <- 30
    kPdfWidthA4Portrait <- (210 - kMarginInner - kMarginOuter) * kMmToInch
    kPdfHeightA4Portrait <- (297 - kMarginTop - kMarginBottom) * kMmToInch
    kPdfWidthA4Landscape <- (297 - kMarginTop - kMarginBottom) * kMmToInch
    kPdfHeightA4Landscape <- (210 - kMarginInner - kMarginOuter) * kMmToInch
    kPdfWidth1by1 <- (210 - 30 - 20) * 0.5 * kMmToInch
    kPdfHeight1by1 <- kPdfWidth1by1
    kPdfWidth1by2 <- 2 * kPdfWidth1by1
    kPdfHeight1by2 <- kPdfHeight1by1
    kPdfWidth2by2 <- kPdfWidth1by2
    kPdfHeight2by2 <- kPdfWidth2by2
    ## Set point size for PDF device.
    kPdfPointSize <- 9
    ## Set font family for PDF device.
    kPdfFamily <- "Times"
    ## Set standard point character for plots.
    kPointCharacter <- 20
    ## Set standard line settings for plots.
    kLineWidth <- 1
    kLineType <- "solid"
    ## Set a distinct color for each species to use in all multi-species plots. Colors are taken from Niedersächsische Landesforsten (2011), fig. 3.
    kSpeciesColors <- list("beech" = "#ee7f00",
		       "spruce" = "#4066aa")
    ## Set plot grid properties.
    kGridLineType <- "dashed"
    kGridLineCol <- "gray"
    kGridLineWidth <- 0.5
    ## Set background color for plot legends.
    kLegendBg <- "gray"
    ## Set vectors of species names.
    kSpeciesNames <- c("beech", "spruce")
    kSpeciesNamesCapitalized <- c("Beech", "Spruce")
    ## Set destination directory for output.
    kOutputSubdir <- "R/Output/Thesis/"
    ## Set destination directory for graphics.
    kGraphicsSubdir <- "Graphics/Thesis/"
    ## If nonexistent, create all required directories.
    system2(command = "mkdir",
	  args = paste0("-p ", c(kGraphicsSubdir, kOutputSubdir)))
    objects.at.script.start <- c(ls(), "objects.at.script.start")  ## Required for cleaning up workspace.
  #+END_SRC
* logDlogNPlotsBeforeAfterDataSelection.pdf
  #+NAME: logDlogNPlotsBeforeAfterDataSelection.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataSelection.tex
    ## This creates 4 plots in one file in a 2-by-2 layout (one row per species, one column per data selection state), showing the effect of the data selection mechanism.
    ## Plotting preamble.
    kPlotMargins <- c(3.5, 3.5, 1, 1)
    kPlotMgp <- c(2, 1, 0)
    kXLab <- expression(paste("log(", italic("D"), ")"))
    kYLab <- expression(paste("log(", italic("N"), ")"))
    kXMin <- list("beech" = 0.8,
	        "spruce" = 0.8)
    kXMax <- list("beech" = 1.8,
	        "spruce" = 1.8)
    kYMin <- list("beech" = 1.6,
	        "spruce" = 2.4 * 0.9)
    kYMax <- list("beech" = 3.6,
	        "spruce" = 3.6)
    kPlotLayout <- 1:4
    kUpperThresholdLineType <- "dashed"
    kLowerThresholdLineType <- "solid"
    kThresholdLinesFrom <- 0
    kThresholdLinesTo <- 10
    kThresholdLinesCol <- "black"
    ## Loop over all species names.
    ## for (cur.species.name in kSpeciesNames) {
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   ## "logDlogNPlotsBeforeAfterDataSelection",
		   ## kSpeciesNamesCapitalized[grep(pattern = cur.species.name, x = kSpeciesNamesCapitalized, ignore.case = TRUE)], ".pdf")
		   "logDlogNPlotsBeforeAfterDataSelection.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidth2by2,
        height = kPdfHeight2by2,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot margins.
    par("mar" = kPlotMargins)
    ## Set plot layout to 2-by-2.
    layout(mat = matrix(data = kPlotLayout,
		    ## nrow = 1,
		    nrow = 2,
		    ncol = 2,
		    ## byrow = FALSE))
		    byrow = TRUE))
    ## Loop over all plot numbers.
    for (cur.plot.nr in kPlotLayout) {
        ## Set current species name ("beech" for plots number 1 and 2, "spruce" for plots number 3 and 4).
        cur.species.name <- ifelse(test = cur.plot.nr <= 2,
			     yes = "beech",
			     no = "spruce")
        ## Extract x- and y-limits for current species.
        cur.xmin <- as.numeric(x = kXMin[names(x = kXMin) == cur.species.name])
        cur.xmax <- as.numeric(x = kXMax[names(x = kXMax) == cur.species.name])
        cur.ymin <- as.numeric(x = kYMin[names(x = kYMin) == cur.species.name])
        cur.ymax <- as.numeric(x = kYMax[names(x = kYMax) == cur.species.name])
        ## Set point and line color for current species.
        cur.point.line.col <- as.character(x = kSpeciesColors[names(x = kSpeciesColors) == cur.species.name])
        ## Set data frame version for current plot number ("1.0" for plots number 1 and 3, "1.8" for plots number 2 and 4).
        cur.data.frame.version <- ifelse(test = cur.plot.nr %% 2 != 0,
				 yes = "1.0",
				 no = "1.8")
        ## Get data frame for current species and plot number.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.", cur.data.frame.version))
        ## Select column specifier for current plot ("A" for plot number 1, "B" for plot number 2, "" for plots number 3 and 4).
        if (cur.plot.nr <=2) {
	  cur.plot.main <- ifelse(test = cur.plot.nr %% 2 != 0,
			      yes = "A",
			      no = "B")
        } else {
	  cur.plot.main <- ""
        }
        ## Set x-axis label for current plot ("" for plots number 1 and 2, kXLab for plots number 3 and 4).
        cur.xlab <- ifelse(test = cur.plot.nr <= 2,
		       yes = "",
		       no = kXLab)
        ## Set y-axis label for current plot (kYLab for plots number 1 and 3, "" for plots number 2 and 4).
        cur.ylab <- ifelse(test = cur.plot.nr %% 2 != 0,
		       yes = kYLab,
		       no = "")
        ## Initiate legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        legend.lwd <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
        ## Create empty plot.
        plot(x = 0,
	   type = "n",
	   xlim = c(cur.xmin, cur.xmax),
	   ylim = c(cur.ymin, cur.ymax),
	   ## xlab = kXLab,
	   xlab = cur.xlab,
	   ## ylab = kYLab,
	   ylab = cur.ylab,
	   xaxs = "i",
	   yaxs = "i",
	   mgp = kPlotMgp,
	   main = cur.plot.main,
	   panel.first = abline(v = seq(from = 0,
				  to = 2,
				  by = 0.2),
			    h = seq(from = 0,
				  to = 4,
				  by = 0.2),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Define function for calculating the lines representing the slope thresholds.
        slope.threshold.func <- function(s, x, k) {
	  res <- s * x + k
	  return(res)
        }
        ## Add line for upper slope threshold to plot.
        cur.species.upper.slope.threshold <- ifelse(test = cur.species.name == "beech",
					  yes = -0.9,
					  no = -0.65)
        cur.species.threshold.func.upper.intercept <- cur.ymax - cur.species.upper.slope.threshold * cur.xmin
        curve(expr = slope.threshold.func(s = cur.species.upper.slope.threshold,
				  x,
				  k = cur.species.threshold.func.upper.intercept),
	    from = kThresholdLinesFrom,
	    to = kThresholdLinesTo,
	    lty = kUpperThresholdLineType,
	    lwd = kLineWidth,
	    col = kThresholdLinesCol,
	    add = TRUE)
        ## Update legend components.
        legend.legend <- c(legend.legend, paste0("upper slope threshold ", cur.species.name))
        legend.pch <- c(legend.pch, NA)
        legend.lty <- c(legend.lty, kUpperThresholdLineType)
        legend.lwd <- c(legend.lwd, kLineWidth)
        legend.col <- c(legend.col, kThresholdLinesCol)
        ## Add line for lower slope threshold to plot.
        cur.species.lower.slope.threshold <- ifelse(test = cur.species.name == "beech",
					  yes = -2.91,
					  no = -2.82)
        cur.species.threshold.func.lower.intercept <- cur.ymax - cur.species.lower.slope.threshold * cur.xmin
        curve(expr = slope.threshold.func(s = cur.species.lower.slope.threshold,
				  x,
				  k = cur.species.threshold.func.lower.intercept),
	    from = kThresholdLinesFrom,
	    to = kThresholdLinesTo,
	    lty = kLowerThresholdLineType,
	    lwd = kLineWidth,
	    col = kThresholdLinesCol,
	    add = TRUE)
        ## Update legend components.
        legend.legend <- c(legend.legend,  paste0("lower slope threshold ", cur.species.name))
        legend.pch <- c(legend.pch, NA)
        legend.lty <- c(legend.lty, kLowerThresholdLineType)
        legend.lwd <- c(legend.lwd, kLineWidth)
        legend.col <- c(legend.col, kThresholdLinesCol)
        ## Loop over all "edvid"s.
        for (cur.edvid.name in levels(x = cur.data.frame[["edvid"]])) {
	  ## Extract x-values for current "edvid".
	  cur.x.values <- cur.data.frame[["log.dg"]][cur.data.frame[["edvid"]] == cur.edvid.name]
	  ## Extract y-values for current "edvid".
	  cur.y.values <- cur.data.frame[["log.nha"]][cur.data.frame[["edvid"]] == cur.edvid.name]
	  ## Add points to plot per "edvid", with distinct colors per species.
	  points(x = cur.x.values,
	         y = cur.y.values,
	         type = "p",
	         pch = kPointCharacter,
	         lty = kLineType,
	         col = cur.point.line.col)
	  ## Add lines to plot per "edvid", with distinct colors per species.
	  lines(x = cur.x.values,
	        y = cur.y.values,
	        lty = kLineType,
	        lwd = kLineWidth,
	        col = cur.point.line.col)
        }
        ## Calculate number of observations in current data frame.
        cur.n <- nrow(x = cur.data.frame)
        ## Calculate number of sample plots in current data frame.
        cur.sample.plots.n <- length(x = levels(x = droplevels(x = cur.data.frame[["edvid"]])))
        ## Update legend components. I am adding 2 elements to each legend component because it’s the only way to insert a line break between the string "Beobachtungen" and the expression containing "cur.n" and "cur.sample.plots.n".
        legend.legend <- c(legend.legend, paste0("observations ", cur.species.name))
        legend.pch <- c(legend.pch, kPointCharacter)
        legend.lty <- c(legend.lty, kLineType)
        legend.lwd <- c(legend.lwd, kLineWidth)
        legend.col <- c(legend.col, cur.point.line.col)
        legend.legend <- c(legend.legend,
		       mapply(FUN = function(expr1, numbr1, expr2, numbr2) { as.expression(x = bquote(.(expr1)*.(numbr1)*", "*.(expr2)*.(numbr2)*")")) },
			    expr1 = expression("("*italic("n")["obs"]*" = "),
			    numbr1 = cur.n,
			    expr2 = expression(italic("n")["sp"]*" = "),
			    numbr2 = cur.sample.plots.n
			    ))
        legend.pch <- c(legend.pch, NA)
        legend.lty <- c(legend.lty, NA)
        legend.lwd <- c(legend.lwd, NA)
        legend.col <- c(legend.col, NA)
        ## Add legend.
        legend(x = "bottomleft",
	     legend = legend.legend,
	     col = legend.col,
	     lty = legend.lty,
	     pch = legend.pch,
	     lwd = legend.lwd,
	     bg = "gray")
        ## Reset legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        legend.lwd <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
    }
    ## Turn off graphics device.
    graphics.off()
    ## }
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* LocationsSamplePlots.pdf
  #+NAME: LocationsSamplePlots.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## This block creates 2 plots (one per species) in one file in a 1-by-2 layout, showing the locations of the sample plots on a map of Germany.
    ## Plotting preamble.
    kPlotMargins <- c(0.5, 0.5, 0.5, 0.5)
    kPlotLayout <- 1:2
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "LocationsSamplePlots.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidth1by2,
        height = kPdfHeight1by2,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout to 1-by-2.
    layout(mat = matrix(data = kPlotLayout,
		    nrow = 1,
		    ncol = 2,
		    byrow = FALSE))
    ## Set plot margins.
    par("mar" = kPlotMargins)
    ## Initiate legend components.
    legend.legend <- vector(mode = "character")
    legend.pch <- vector(mode = "numeric")
    legend.col <- vector(mode = "character")
    ## Loop over all plot numbers.
    for (cur.plot.nr in kPlotLayout) {
        ## Set current species name ("beech" for plot number 1, "spruce" for plot number 2).
        cur.species.name <- ifelse(test = cur.plot.nr == 1,
			     yes = "beech",
			     no = "spruce")
        ## Set point and line color for current species.
        cur.point.line.col <- as.character(x = kSpeciesColors[names(x = kSpeciesColors) == cur.species.name])
        ## Get data frame for current species and plot number.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Condense "cur.data.frame" to the unique values of columns "edvid", "EAST.UTM", and "NORTH.UTM".
        cur.data.frame <- unique(x = cur.data.frame[, c("edvid", "EAST.UTM", "NORTH.UTM")])
        ## Extract easting and northing.
        easting <- cur.data.frame[["EAST.UTM"]]
        northing <- cur.data.frame[["NORTH.UTM"]]
        ## Calculate plot axis limits.
        x.lim.low <- range(easting, na.rm = TRUE)[1]
        x.lim.high <- range(easting, na.rm = TRUE)[2]
        y.lim.low <- range(northing, na.rm = TRUE)[1]
        y.lim.high <- range(northing, na.rm = TRUE)[2]
        x.lim <- c(x.lim.low, x.lim.high)
        y.lim <- c(y.lim.low, y.lim.high)
        ## Plot national and federal state boundaries.
        library("sp")
        plot(x = bld_utm,
	   add = FALSE,
	   lwd = kLineWidth)
        ## Add points at sample plot locations to plot.
        points(x = easting,
	     y = northing,
	     xlab = "Easting",
	     ylab = "Northing",
	     col = cur.point.line.col,
	     pch = kPointCharacter)
        ## Draw box around plot.
        box(bty = "o")
        ## Update legend components.
        legend.legend <- c(legend.legend, paste0("sample plots ", cur.species.name))
        legend.pch <- c(legend.pch, kPointCharacter)
        legend.col <- c(legend.col, cur.point.line.col)
        ## Add legend.
        legend(x = "bottomright",
	     legend = legend.legend,
	     pch = legend.pch,
	     col = legend.col,
	     bg = "gray")
        ## Reset legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* SpeciesAltitudeOfSamplePlots.pdf
  #+NAME: SpeciesAltitudeOfSamplePlots.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Plotting preamble.
    kPlotMargins <- c(3, 3, 0.5, 0.75)
    kPlotMgp <- c(2, 1, 0)
    kXValues <- seq(from = 1, to = 2, by = 0.5)
    kXMin <- min(kXValues)
    kXMax <- max(kXValues)
    kYMin <- min(bart.beech.clean.1.8[["hnn.neu"]],
	       bart.spruce.clean.1.8[["hnn.neu"]],
	       na.rm = TRUE)
    kYMax <- round(x = max(bart.beech.clean.1.8[["hnn.neu"]],
		       bart.spruce.clean.1.8[["hnn.neu"]],
		       na.rm = TRUE),
	         digits = -2)
    kYAxisTicks <- seq(from = 0,
		   to = kYMax,
		   by = 100)
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "SpeciesAltitudeOfSamplePlots.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidth1by1,
        height = kPdfHeight1by1,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot margins.
    par("mar" = kPlotMargins)
    ## Create empty plot.
    plot(x = kXValues,
         xlim = c(kXMin, kXMax),
         ylim = c(kYMin, kYMax),
         xlab = "Species",
         ylab = "Altitude above sea level [m]",
         mgp = kPlotMgp,
         type = "n",
         axes = FALSE,
         panel.first = abline(h = kYAxisTicks,
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			col = kGridLineCol))
    axis(side = 1,
         labels = kSpeciesNamesCapitalized,
         at = c(1, 2))
    axis(side = 2,
         labels = TRUE,
         at = seq(from = kYAxisTicks[1],
	        to = kYAxisTicks[length(x = kYAxisTicks)],
	        by = 200))
    ## Draw box around plot.
    box(bty = "o")
    ## Initiate legend components.
    legend.legend <- vector(mode = "character")
    legend.col <- vector(mode = "character")
    legend.pch <- vector(mode = "numeric")
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get point color for current species.
        cur.point.color <- kSpeciesColors[[cur.species.name]]
        ## Get data frame for current species.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Make data frame unique with respect to columns "edvid" and "hnn.neu".
        cur.data.frame.unique <- unique(x = cur.data.frame[, c("edvid", "hnn.neu")])
        ## Add points to plot.
        points(x = rep(x = which(x = kSpeciesNames == cur.species.name), times = length(x = cur.data.frame.unique[["hnn.neu"]])),
	     y = cur.data.frame.unique[["hnn.neu"]],
	     col = cur.point.color,
	     pch = kPointCharacter)
        ## Update legend components.
        legend.legend <- c(legend.legend, paste0("sample plots ", cur.species.name))
        legend.col <- c(legend.col, cur.point.color)
        legend.pch <- c(legend.pch, kPointCharacter)
    }
    ## Add legend.
    legend(x = "topleft",
	 legend = legend.legend,
	 pch = legend.pch,
	 col = legend.col,
	 bg = kLegendBg)
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* StandAgeTopHeightYieldClassClassification.pdf
** General procedure:
   1. Set SI.h100 values per yield class based on Schober (1995) (moderate thinning).
   2. Generate a sequence of SI.h100 values from the worst yield class to the best yield class needed to cover the observed range of SI.h100 values, with a distance of 0.1 between sequence elements.
   3. Generate a color palette based on the result of 2.
   4. Map the observed SI.h100 values to the corresponding color of the color palette from 3. for plotting.
   5. Map the SI.h100 value of each yield class to the corresponding color of the color palette from 3. for the legend.
** R Code
   #+NAME: StandAgeTopHeightYieldClassClassification.pdf
   #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
     ## Plotting preamble.
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kLegendX <- "bottomright"
     kXLim <- c(0, 160)
     kYLim <- c(0, 40)
     ## Define color palette generating function.
     kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
     ## Set best yield class level for which to interpolate SI.h100 values
     kBestYieldClassLevel <- -2
     ## Turn off graphics device.
     graphics.off()
     ## Create file name.
     file.name <-paste0(kGraphicsSubdir,
		    "StandAgeTopHeightYieldClassClassification.pdf")
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = file.name,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.85,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over all species names.
     for (cur.species.name in kSpeciesNames) {
         ## Get data frame for current species.
         bart.cur.species.clean.1.8 <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
         ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
         SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
					"SI.h100" = NA)
         ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
         if (cur.species.name == "beech") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
         }
         if (cur.species.name == "spruce") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
         }
         ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
         for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	   SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	   SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
         }
         ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
         SI.h100.min <- min(bart.cur.species.clean.1.8[["SI.h100"]],
		        na.rm = TRUE)
         SI.h100.max <- max(bart.cur.species.clean.1.8[["SI.h100"]],
		        na.rm = TRUE)
         index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
         index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
         ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
         SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				   to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				   by = 0.1),
			     digits = 1)
         ## Generate a color palette of the same length as "SI.h100.sequence".
         cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Create empty plot.
         plot(x = bart.cur.species.clean.1.8[["alt"]],
	    type = "n",
	    xlim = kXLim,
	    ylim = kYLim,
	    xlab = "stand age [a]",
	    ylab = expression(italic("h")[100]*" [m]"),,
	    main = kSpeciesNamesCapitalized[grep(pattern = cur.species.name,
					 x = kSpeciesNamesCapitalized,
					 ignore.case = TRUE)],
	    mgp = kPlotMgp,
	    xaxs = "i",
	    yaxs = "i",
	    panel.first = abline(v = seq(from = kXLim[1],
				   to = kXLim[2],
				   by = 10),
			     h  = seq(from = kYLim[1],
				    to = kYLim[2],
				    by = 5),
			     lty = kGridLineType,
			     lwd = kGridLineWidth,
			     col = kGridLineCol))
         ## Loop over all evdids.
         for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	   ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	   edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			      subset = edvid == cur.edvid)
	   ## Add lines for observations belonging to current edvid.
	   lines(x =edvid.subset[["alt"]],
	         y = edvid.subset[["h100"]],
	         lwd = kLineWidth,
	         lty = kLineType)
         }
         ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
         for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	   ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	   edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			      subset = edvid == cur.edvid)
	   ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	   SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
					table = SI.h100.sequence)
	   ## Add points to plot.
	   points(x = edvid.subset[["alt"]],
		y = edvid.subset[["h100"]],
		col = cur.species.color.palette[SI.h100.rounded.color.index],
		pch = kPointCharacter)
         }
         ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
         SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						       digits = 1),
				      table = SI.h100.sequence)
         ## Add legend.
         legend.legend <- c(paste0("yield class ",
			     SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
         legend.col <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
         legend.pch <- kPointCharacter
         legend(x = kLegendX,
	      legend = legend.legend,
	      col = legend.col,
	      pch = legend.pch,
	      bg = kLegendBg)
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.                                   
     rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
* ObservationsCountPerEdvidSPECIES.txt
  #+NAME: ObservationsCountPerEdvidSPECIES.txt
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Extract capitalized version of current species name.
        cur.species.name.capitalized <- kSpeciesNamesCapitalized[grep(pattern = cur.species.name,
							x = kSpeciesNamesCapitalized,
							ignore.case = TRUE)]
        ## Get data frame for current species.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Create a subset with only columns "edvid", "h100.EKL.I", and "SI.h100.diff.EKL.I".
        cur.data.frame <- subset(x = cur.data.frame, select = c("edvid", "h100.EKL.I", "SI.h100.diff.EKL.I"))
        ## Count observations per edvid.
        obs.per.edvid <- table(cur.data.frame[["edvid"]])
        ## Store results in data frame.
        cur.species.results.df <- data.frame("edvid" = names(x = obs.per.edvid),
				     "observations.count" = as.numeric(x = obs.per.edvid),
				     stringsAsFactors = FALSE)
        ## Calculate sum of each column.
        cur.species.results.df <- rbind(cur.species.results.df,
				data.frame("edvid" = c(as.character(x = nrow(x = cur.species.results.df)),
						   NA,
						   NA,
						   NA,
						   NA),
					 "observations.count" = c(sum(cur.species.results.df[["observations.count"]]),
							      min(cur.species.results.df[["observations.count"]]),
							      mean(cur.species.results.df[["observations.count"]]),
							      median(cur.species.results.df[["observations.count"]]),
							      max(cur.species.results.df[["observations.count"]]))
					 ))
        ## Set rownames.
        rownames(x = cur.species.results.df) <- c(rownames(x = cur.species.results.df)[1:(length(x = rownames(x = cur.species.results.df)) - 5)],
					"total",
					"min",
					"mean",
					"median",
					"max")
        ## Round column "observations.count" to 1 decimal digit.
        cur.species.results.df[["observations.count"]] <- round(x = cur.species.results.df[["observations.count"]],
						    digits = 1)
        ## Store printing of "cur.species.results.df" in "cur.output", while left justifying output.
        cur.output <- capture.output(print(x = format(x = cur.species.results.df,
					    justify="left",
					    scientific = FALSE),
				   row.names = TRUE))
        ## Output results to file.
        cat(cur.output,
	  file = paste0(kOutputSubdir, "ObservationsCountPerEdvid", cur.species.name.capitalized, ".txt"),
	  sep = "\n",
	  fill = FALSE)
    }
    ## Clean up workspace.                                   
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* StandAgeBasalAreaYieldClassClassification.pdf
  #+NAME: StandAgeBasalAreaYieldClassClassification.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Plotting preamble.
    kPlotMargins <- c(3, 3.25, 2, 1)
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:2,
		      nrow = 2,
		      ncol = 1)
    kLegendX <- "topright"
    kXLim <- c(0, 160)
    kYLim <- c(0, 85)
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "StandAgeBasalAreaYieldClassClassification.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidthA4Portrait,
        height = kPdfHeightA4Portrait * 0.85,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get data frame for current species.
        bart.cur.species.clean.1.8 <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
        SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				         "SI.h100" = NA)
        ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
        if (cur.species.name == "beech") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
        }
        if (cur.species.name == "spruce") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
        }
        ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
        for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	  SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	  SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
        }
        ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
        SI.h100.min <- min(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        SI.h100.max <- max(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
        index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
        ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
        SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				  to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				  by = 0.1),
			    digits = 1)
        ## Generate a color palette of the same length as "SI.h100.sequence".
        cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
        ## Set plot margins.
        par("mar" = kPlotMargins)
        ## Create empty plot.
        plot(x = bart.cur.species.clean.1.8[["alt"]],
	   type = "n",
	   xlim = kXLim,
	   ylim = kYLim,
	   xlab = "stand age [a]",
	   ylab = expression(italic("G")*" [m"^2*" ha"^-1*"]"),
	   main = kSpeciesNamesCapitalized[grep(pattern = cur.species.name,
					x = kSpeciesNamesCapitalized,
					ignore.case = TRUE)],
	   mgp = kPlotMgp,
	   xaxs = "i",
	   yaxs = "i",
	   panel.first = abline(v = seq(from = kXLim[1],
				  to = kXLim[2],
				  by = 10),
			    h  = seq(from = kYLim[1],
				   to = kYLim[2],
				   by = 10),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Loop over all evdids.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Add lines for observations belonging to current edvid.
	  lines(x =edvid.subset[["alt"]],
	        y = edvid.subset[["gha"]],
	        lwd = kLineWidth,
	        lty = kLineType)
        }
        ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	  SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				         table = SI.h100.sequence)
	  ## Add points to plot.
	  points(x = edvid.subset[["alt"]],
	         y = edvid.subset[["gha"]],
	         col = cur.species.color.palette[SI.h100.rounded.color.index],
	         pch = kPointCharacter)
        }
        ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
        SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						      digits = 1),
					      table = SI.h100.sequence)
        ## Add legend.
        legend.legend <- c(paste0("yield class ",
			    SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        legend.col <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
        legend.pch <- kPointCharacter
        legend(x = kLegendX,
	     legend = legend.legend,
	     col = legend.col,
	     pch = legend.pch,
	     bg = kLegendBg)
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* StandAgeProductivityIndexYieldClassClassification.pdf
  #+NAME: StandAgeProductivityIndexYieldClassClassification.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Plotting preamble.
    kPlotMargins <- c(3, 3.25, 2, 1)
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:2,
		      nrow = 2,
		      ncol = 1)
    kLegendX <- "topright"
    kLegendNCol <- 2
    kYieldClassSIValuesLineType <- "dashed"
    kXLim <- c(0, 160)
    kYLim <- c(20, 50)
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "StandAgeProductivityIndexYieldClassClassification.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidthA4Portrait,
        height = kPdfHeightA4Portrait * 0.85,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get data frame for current species.
        bart.cur.species.clean.1.8 <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
        SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				         "SI.h100" = NA)
        ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
        if (cur.species.name == "beech") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
        }
        if (cur.species.name == "spruce") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
        }
        ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
        for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	  SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	  SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
        }
        ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
        SI.h100.min <- min(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        SI.h100.max <- max(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
        index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
        ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
        SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				  to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				  by = 0.1),
			    digits = 1)
        ## Generate a color palette of the same length as "SI.h100.sequence".
        cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
        ## Initiate legend components.
        legend.legend <- vector(mode = "expression")
        legend.col <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        ## Set plot margins.
        par("mar" = kPlotMargins)
        ## Create empty plot.
        plot(x = bart.cur.species.clean.1.8[["alt"]],
	   type = "n",
	   xlim = kXLim,
	   ylim = kYLim,
	   xlab = "stand age [a]",
	   ylab = expression(italic("PI")*" [m]"),
	   main = kSpeciesNamesCapitalized[grep(pattern = cur.species.name,
					x = kSpeciesNamesCapitalized,
					ignore.case = TRUE)],
	   mgp = kPlotMgp,
	   xaxs = "i",
	   yaxs = "i",
	   panel.first = abline(v = seq(from = kXLim[1],
				  to = kXLim[2],
				  by = 10),
			    ## h  = seq(from = kYLim[1],
			    ## to = kYLim[2],
			    ## by = 5),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
        SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						      digits = 1),
					      table = SI.h100.sequence)
        ## Add horizontal lines at the central value of each yield class.
        abline(h = SI.h100.yield.class.values[["SI.h100"]][index.worst.yield.class.needed:index.best.yield.class.needed],
	     col = cur.species.color.palette[SI.h100.yield.class.values.color.index],
	     lty = kYieldClassSIValuesLineType)
        ## Update legend components.
        legend.legend <- c(legend.legend,
		       mapply(FUN = function(expr, numbr1, numbr2) { as.expression(x = bquote(.(expr)*.(numbr1)*" ("*.(numbr2)*" m)")) },  ## See https://stackoverflow.com/questions/27275798/combining-vector-variables-in-r-expression-for-plot-text?noredirect=1.
			    expr = expression(italic("PI")*" yield class "),
			    numbr1 = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"],
			    numbr2 = SI.h100.yield.class.values[["SI.h100"]][index.worst.yield.class.needed:index.best.yield.class.needed])
    )
        legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
        legend.pch <- c(legend.pch, rep(x = NA,
				times = length(x = SI.h100.yield.class.values.color.index)))
        legend.lty <- c(legend.lty, rep(x = kYieldClassSIValuesLineType,
				times = length(x = SI.h100.yield.class.values.color.index)))
        ## Loop over all evdids.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Add lines for observations belonging to current edvid.
	  lines(x =edvid.subset[["alt"]],
	        y = edvid.subset[["SI.h100"]],
	        lwd = kLineWidth,
	        lty = kLineType)
        }
        ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	  SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				         table = SI.h100.sequence)
	  ## Add points to plot.
	  points(x = edvid.subset[["alt"]],
	         y = edvid.subset[["SI.h100"]],
	         col = cur.species.color.palette[SI.h100.rounded.color.index],
	         pch = kPointCharacter)
        }
        ## Update legend components.
        legend.legend <- c(legend.legend, paste0("observations yield class ",
				         SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
        legend.pch <- c(legend.pch, rep(x = kPointCharacter,
				times = length(x = SI.h100.yield.class.values.color.index)))
        legend.lty <- c(legend.lty, rep(x = NA,
				times = length(x = SI.h100.yield.class.values.color.index)))
        ## Add legend.
        legend(x = kLegendX,
	     ncol = kLegendNCol,
	     legend = legend.legend,
	     col = legend.col,
	     pch = legend.pch,
	     bg = kLegendBg,
	     lty = legend.lty)
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* VariablesStatisticsSPECIES.txt
  #+NAME: StatisticsOfVariablesSPECIES.txt
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Preamble.
    kVariablesColumnNames <- c("alt",  ## All variables must be numeric.
			 "h100",
			 "gha",
			 "SI.h100",
			 "hnn.neu",
			 "Reineke.slope")
    kStatisticFunctionsNames <- c("min",  ## All functions need to accept argument "x" as their input and argument "na.rm = TRUE".
			    "median",
			    "mean",
			    "max",
			    "span")
    kRoundDigits <- c("Reineke.slope" = 3)
    span <- function(x, na.rm = TRUE) {
        var.min <- min(x = x,
		   na.rm = na.rm)
        var.max <- max(x = x,
		   na.rm = na.rm)
        res <- var.max - var.min
        return(res)
    }
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Initiate list in which to store results for current species.
        cur.species.results.list <- vector(mode = "list")
        ## Extract capitalized version of current species name.
        cur.species.name.capitalized <- kSpeciesNamesCapitalized[grep(pattern = cur.species.name,
							x = kSpeciesNamesCapitalized,
							ignore.case = TRUE)]
        ## Loop over the names of all appropriate data frames.
        data.frame.names <- ls(pattern = paste0("bart.", cur.species.name, ".clean.1.[08]"))
        for (cur.data.frame.name in data.frame.names) {
	  ## Get current data frame for current species.
	  cur.data.frame <- get(x = cur.data.frame.name)
	  ## Initiate object in which to store results for current data frame.
	  cur.data.frame.results.df <- data.frame(matrix(data = NA,
					         nrow = length(x = kStatisticFunctionsNames),
					         ncol = 1 + length(x = kVariablesColumnNames)))
	  colnames(x = cur.data.frame.results.df) <- c("statistic", kVariablesColumnNames)
	  cur.data.frame.results.df[["statistic"]] <- kStatisticFunctionsNames
	  ## Loop over all column names of the variables of interest.
	  for (cur.col.name in kVariablesColumnNames) {
	      ## Loop over all statistic function names.
	      for (cur.stat.fun.name in kStatisticFunctionsNames) {
		## Get current statistic function.
		cur.stat.fun <- get(x = cur.stat.fun.name)
		## If a number of decimal digits for rounding has been set for the current column, use that, otherwise set it to 1.
		if (cur.col.name %in% names(x = kRoundDigits)) {
		    cur.round.digits <- kRoundDigits[[cur.col.name]]
		} else {
		    cur.round.digits <- 1
		}
		## Calclulate current statistic and store it in the appropriate row and column of "cur.data.frame.results.df".
		cur.data.frame.results.df[cur.data.frame.results.df[["statistic"]] == cur.stat.fun.name, cur.col.name] <- round(x = cur.stat.fun(x = cur.data.frame[[cur.col.name]],
														         na.rm = TRUE),
													  digits = cur.round.digits)
	      }}
	  ## Append "cur.data.frame.results.df" to "cur.species.results.list".
	  if (length(x = cur.species.results.list) == 0) {
	      cur.species.results.list <- list(cur.data.frame.results.df)
	  } else {
	      cur.species.results.list <- c(cur.species.results.list,
				      list(cur.data.frame.results.df))
	  }}
        ## Set names of "cur.species.results.list".
        names(x = cur.species.results.list) <- data.frame.names
        ## Store printing of "cur.species.results.list" in "cur.output", while left justifying output.
        cur.output <- capture.output(print(x = cur.species.results.list,
				   row.names = TRUE))
        ## Output results to file.
        cat(cur.output,
	  file = paste0(kOutputSubdir, "VariablesStatistics", cur.species.name.capitalized, ".txt"),
	  sep = "\n",
	  fill = FALSE)
    }
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* StandAgeStandAgeVariableYieldClassClassification.pdf
  #+NAME: StandAgeStandAgeVariableYieldClassClassification.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Plotting preamble.
    kPlotMargins <- c(3, 3.25, 2, 1)
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:2,
		      nrow = 2,
		      ncol = 1)
    kLegendX <- "bottomright"
    kXLim <- c(0, 160)
    kYLim <- c(0, 50)
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "StandAgeStandAgeVariableYieldClassClassification.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidthA4Portrait,
        height = kPdfHeightA4Portrait * 0.85,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get data frame for current species.
        bart.cur.species.clean.1.8 <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
        SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				         "SI.h100" = NA)
        ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
        if (cur.species.name == "beech") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
        }
        if (cur.species.name == "spruce") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
        }
        ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
        for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	  SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	  SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
        }
        ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
        SI.h100.min <- min(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        SI.h100.max <- max(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
        index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
        ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
        SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				  to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				  by = 0.1),
			    digits = 1)
        ## Generate a color palette of the same length as "SI.h100.sequence".
        cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
        ## Set plot margins.
        par("mar" = kPlotMargins)
        ## Create empty plot.
        plot(x = bart.cur.species.clean.1.8[["alt"]],
	   type = "n",
	   xlim = kXLim,
	   ylim = kYLim,
	   xlab = "stand age [a]",
	   ylab = expression(italic("h")[100]*"("*italic("x")*")"["I. YC"]*" [m]"),
	   main = kSpeciesNamesCapitalized[grep(pattern = cur.species.name,
					x = kSpeciesNamesCapitalized,
					ignore.case = TRUE)],
	   mgp = kPlotMgp,
	   xaxs = "i",
	   yaxs = "i",
	   panel.first = abline(v = seq(from = kXLim[1],
				  to = kXLim[2],
				  by = 10),
			    h  = seq(from = kYLim[1],
				   to = kYLim[2],
				   by = 5),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Loop over all evdids.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Add lines for observations belonging to current edvid.
	  ## lines(x =edvid.subset[["alt"]],
	        ## y = edvid.subset[["h100.EKL.I"]],
	        ## lwd = kLineWidth,
	        ## lty = kLineType)
        }
        ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	  SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				         table = SI.h100.sequence)
	  ## Add points to plot.
	  points(x = edvid.subset[["alt"]],
	         y = edvid.subset[["h100.EKL.I"]],
	         col = cur.species.color.palette[SI.h100.rounded.color.index],
	         pch = kPointCharacter)
        }
        ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
        SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						      digits = 1),
					      table = SI.h100.sequence)
        ## Add legend.
        legend.legend <- c(paste0("yield class ",
			    SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        legend.col <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
        legend.pch <- kPointCharacter
        legend(x = kLegendX,
	     legend = legend.legend,
	     col = legend.col,
	     pch = legend.pch,
	     bg = kLegendBg)
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* StandAgeProductivityIndexVariableYieldClassClassification.pdf
  #+NAME: StandAgeProductivityIndexVariableYieldClassClassification.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Plotting preamble.
    kPlotMargins <- c(3, 3.25, 2, 1)
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:2,
		      nrow = 2,
		      ncol = 1)
    kLegendX <- "topright"
    kXLim <- c(0, 160)
    kYLim <- c(-20, 20)
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "StandAgeProductivityIndexVariableYieldClassClassification.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidthA4Portrait,
        height = kPdfHeightA4Portrait * 0.85,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get data frame for current species.
        bart.cur.species.clean.1.8 <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
        SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				         "SI.h100" = NA)
        ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
        if (cur.species.name == "beech") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
        }
        if (cur.species.name == "spruce") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
        }
        ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
        for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	  SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	  SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
        }
        ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
        SI.h100.min <- min(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        SI.h100.max <- max(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
        index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
        ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
        SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				  to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				  by = 0.1),
			    digits = 1)
        ## Generate a color palette of the same length as "SI.h100.sequence".
        cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
        ## Set plot margins.
        par("mar" = kPlotMargins)
        ## Create empty plot.
        plot(x = bart.cur.species.clean.1.8[["alt"]],
	   type = "n",
	   xlim = kXLim,
	   ylim = kYLim,
	   xlab = "stand age [a]",
	   ylab = expression(italic("PI")["diff"]*" [m]"),
	   main = kSpeciesNamesCapitalized[grep(pattern = cur.species.name,
					x = kSpeciesNamesCapitalized,
					ignore.case = TRUE)],
	   mgp = kPlotMgp,
	   xaxs = "i",
	   yaxs = "i",
	   panel.first = abline(v = seq(from = kXLim[1],
				  to = kXLim[2],
				  by = 10),
			    h  = seq(from = kYLim[1],
				   to = kYLim[2],
				   by = 5),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Loop over all evdids.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Add lines for observations belonging to current edvid.
	  lines(x =edvid.subset[["alt"]],
	        y = edvid.subset[["SI.h100.diff.EKL.I"]],
	        lwd = kLineWidth,
	        lty = kLineType)
        }
        ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	  SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				         table = SI.h100.sequence)
	  ## Add points to plot.
	  points(x = edvid.subset[["alt"]],
	         y = edvid.subset[["SI.h100.diff.EKL.I"]],
	         col = cur.species.color.palette[SI.h100.rounded.color.index],
	         pch = kPointCharacter)
        }
        ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
        SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						      digits = 1),
					      table = SI.h100.sequence)
        ## Add legend.
        legend.legend <- c(paste0("yield class ",
			    SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        legend.col <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
        legend.pch <- kPointCharacter
        legend(x = kLegendX,
	     legend = legend.legend,
	     col = legend.col,
	     pch = legend.pch,
	     bg = kLegendBg)
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* ProductivityIndexVariableCounts.txt
  #+NAME: ProductivityIndexVariableCounts.txt
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Preamble.
    res.df.col.names <- c("Species",
		      "n.SI.h100.diff.EKL.I.geq.0",
		      "n.SI.h100.diff.EKL.I.less.0")
    ## Create data frame in which to store results for output.
    res.df <- data.frame(matrix(data = NA,
			  nrow = length(x = kSpeciesNames),
			  ncol = length(x = res.df.col.names)))
    colnames(x = res.df) <- res.df.col.names
    ## Set species names in "res.df".
    res.df[["Species"]] <- kSpeciesNamesCapitalized
    ## Loop over species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get capitalized species name.
        cur.species.name.capitalized <- kSpeciesNamesCapitalized[grep(pattern = cur.species.name,
							x = kSpeciesNamesCapitalized,
							ignore.case = TRUE)]
        ## Get data frame for current species.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Count occurrence of SI.h100.diff.EKL.I >= 0.
        res.df[res.df[["Species"]] == cur.species.name.capitalized, "n.SI.h100.diff.EKL.I.geq.0"] <- length(x = which(x = cur.data.frame[["SI.h100.diff.EKL.I"]] >= 0))
        ## Count occurrence of SI.h100.diff.EKL.I < 0.
        res.df[res.df[["Species"]] == cur.species.name.capitalized, "n.SI.h100.diff.EKL.I.less.0"] <- length(x = which(x = cur.data.frame[["SI.h100.diff.EKL.I"]] < 0))
    }
    ## Store printing of "res.df" in "output", while left justifying output.
    output <- capture.output(print(x = format(x = res.df,
				      justify="left",
				      scientific = FALSE),
			     row.names = TRUE))
    ## Output results to file.
    cat(output,
        file = paste0(kOutputSubdir, "ProductivityIndexVariableCounts.txt"),
        sep = "\n",
        fill = FALSE)
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* CorrelationCoefficients.txt
  #+NAME: CorrelationCoefficients.txt
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Preamble.
    kNamesOfColumnsToEvaluate <- c("alt", "SI.h100.diff.EKL.I", "h100.EKL.I")
    ## Initiate list in which to store results for all species.
    results.list <- vector(mode = "list")
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Initiate data frame in which to store results of current species.
        cur.species.results.df <- data.frame(matrix(data = NA,
					  nrow = length(x = kNamesOfColumnsToEvaluate),
					  ncol = length(x = kNamesOfColumnsToEvaluate)))
        colnames(x = cur.species.results.df) <- kNamesOfColumnsToEvaluate
        rownames(x = cur.species.results.df) <- kNamesOfColumnsToEvaluate
        ## Get source data frame for current species.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Loop over all rows in "cur.species.results.df".
        for (cur.row.index in seq_len(length.out = nrow(x = cur.species.results.df))) {
	  ## Loop over all columns in "cur.species.results.df".
	  for (cur.col.index in seq_len(length.out = ncol(x = cur.species.results.df))) {
	      ## Calclulate correlation coefficient between source data frame columns of interest.
	      cur.x.col.name <- colnames(x = cur.species.results.df)[cur.col.index]
	      cur.y.col.name <- rownames(x = cur.species.results.df)[cur.row.index]
	      cur.cor <- cor(x = cur.data.frame[[cur.x.col.name]],
			 y = cur.data.frame[[cur.y.col.name]])
	      ## Store result in appropriate cell of "cur.species.results.df".
	      cur.species.results.df[cur.row.index, cur.col.index] <- cur.cor
	  }}
        ## Append "cur.species.results.df" to "results.list".
        if (length(x = results.list) == 0) {
	  results.list <- list(cur.species.results.df)
        } else {
	  results.list <- c(results.list,
			list(cur.species.results.df))
        }}
    ## Set names of "results.list".
    names(x = results.list) <- kSpeciesNamesCapitalized
    ## Store printing of "results.list" in "cur.output", while left justifying output.
    cur.output <- capture.output(print(x = results.list,
			         row.names = TRUE))
    ## Output results to file.
    cat(cur.output,
        file = paste0(kOutputSubdir, "CorrelationCoefficients.txt"),
        sep = "\n",
        fill = FALSE)
  #+END_SRC
* File local variables
  # Local Variables:
  # End:

