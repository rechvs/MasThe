#+STARTUP: hideblocks
* Preamble
  #+NAME: Preamble
  #+BEGIN_SRC R :results silent :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/MasAr_Thesis.tex
    rm(list = ls())
    setwd(dir = "~/laptop02_MasAr")
    kDataDir <- "Data/"
    ## Load data set.
    kBaseFileVersion <- "5.5"
    kBaseFileName <- paste0(kDataDir, "gmax_merged_", kBaseFileVersion, ".RData")
    kgmaxObjects <- load(file = kBaseFileName, verbose = TRUE)
    ## Set dimensions of PDF device.
    kCmToInch <- 1 / 2.54
    kMmToInch <- 1 / 25.4
    kMarginTop <- 20  ## For margins see "~/Uni/Formatvorlagen/LaTeX/settings.tex", block "geometry".
    kMarginOuter <- kMarginTop
    kMarginBottom <- kMarginTop
    kMarginInner <- 30
    kPdfWidthA4Portrait <- (210 - kMarginInner - kMarginOuter) * kMmToInch
    kPdfHeightA4Portrait <- (297 - kMarginTop - kMarginBottom) * kMmToInch
    kPdfWidthA4Landscape <- (297 - kMarginTop - kMarginBottom) * kMmToInch
    kPdfHeightA4Landscape <- (210 - kMarginInner - kMarginOuter) * kMmToInch
    kPdfWidth1by1 <- (210 - 30 - 20) * 0.5 * kMmToInch
    kPdfHeight1by1 <- kPdfWidth1by1
    kPdfWidth1by2 <- 2 * kPdfWidth1by1
    kPdfHeight1by2 <- kPdfHeight1by1
    kPdfWidth2by2 <- kPdfWidth1by2
    kPdfHeight2by2 <- kPdfWidth2by2
    ## Set point size for PDF device.
    kPdfPointSize <- 9
    ## Set font family for PDF device.
    kPdfFamily <- "Times"
    ## Set standard point character for plots.
    kPointCharacter <- 20
    ## Set standard line settings for plots.
    kLineWidth <- 1
    kLineType <- "solid"
    ## Set a distinct color for each species to use in all multi-species plots. Colors are taken from Niedersächsische Landesforsten (2011), fig. 3.
    kSpeciesColors <- list("beech" = "#ee7f00",
		       "spruce" = "#4066aa")
    ## Set plot grid properties.
    kGridLineType <- "dashed"
    kGridLineCol <- "gray"
    kGridLineWidth <- 0.5
    ## Set background color for plot legends.
    kLegendBg <- "gray"
    ## Set vectors of species names.
    kSpeciesNames <- c("beech", "spruce")
    kSpeciesNamesCapitalized <- list("beech" = "Beech",
			       "spruce" = "Spruce")
    ## Set destination directory for output.
    kOutputSubdir <- "R/Output/Thesis/"
    ## Set destination directory for graphics.
    kGraphicsSubdir <- "Graphics/Thesis/"
    ## Set names of dependent and predictor variables.
    kStandAgeVariableMathName <- quote(italic("h")[100]*"("*italic("x")*")"["YC 1"])
    kProductivityIndexVariableMathName <- quote(italic("PI")["diff"])
    kDependentVariableRName <- "gha"
    kStandAgeVariableRName <- "h100.EKL.I"
    kProductivityIndexVariableRName <- "SI.h100.diff.EKL.I"
    ## Set model formulas.
    kFormulas <- list("GAM1" = as.formula(object = paste0(kDependentVariableRName, " ~ s(", kStandAgeVariableRName, ") + s(", kProductivityIndexVariableRName, ")")),
		  "GAM2" = as.formula(object = paste0(kDependentVariableRName, " ~ s(", kStandAgeVariableRName, ") + ", kProductivityIndexVariableRName, "")),
		  "SCAM1" = as.formula(object = paste0(kDependentVariableRName, " ~ s(", kStandAgeVariableRName, ", bs = \"micv\") + ", kProductivityIndexVariableRName, "")),
		  "GAMLSS1" = as.formula(object = paste0(kDependentVariableRName, " ~ ps(", kStandAgeVariableRName, ") + ps(", kProductivityIndexVariableRName, ")")),
		  "GAMLSS2" = as.formula(object = paste0(kDependentVariableRName, " ~ ps(", kStandAgeVariableRName, ") + ", kProductivityIndexVariableRName, "")),
		  "GAMLSS3" = as.formula(object = paste0(kDependentVariableRName, " ~ pbm(h100.EKL.I) + ", kProductivityIndexVariableRName, "")))
    ## Define functions for calculating the stand age variable and the productivity index variable.
    CalculateStandAgeVariable <- function(age, piyc1, b0, b1, b2, b3, b4) {
        y <- b0 + b1 * log(x = age) + b2 * (log(x = age)) ^ 2 + piyc1 * (b3 + b4 * log(x = age))
        return(y)
    }
    CalculateProductivityIndexVariable <- function(h100, age, b0, b1, b2, b3, b4, piyc1) {
        pi <- (h100 - b0 - b1 * log(x = age) - b2 * (log(x = age)) ^ 2) / (b3 + b4 * log(x = age))
        y <- pi - piyc1
        return(y)
    }
    ## Set species-specific coefficients for the functions for calculating stand age variable and productivity index variable (values taken from Nagel (1999), tab. 4).
    beta0 <- list("beech" = -75.659,
	        "spruce" = -49.872)
    beta1 <- list("beech" = 23.192,
	        "spruce" = 7.3309)
    beta2 <- list("beech" = -1.468,
	        "spruce" = 0.77338)
    beta3 <- list("beech" = 0,
	        "spruce" = 0.52684)
    beta4 <- list("beech" = 0.2152,
	        "spruce" = 0.10542)
    ## Set species-specific absolute producitivity indices of stand of yield class I (values taken from Schober (1995) (moderate thinning)).
    PI1.YC <- list("beech" = 32.4,
	         "spruce" = 35.1)
    ## If nonexistent, create all required directories.
    system2(command = "mkdir",
	  args = paste0("-p ", c(kGraphicsSubdir, kOutputSubdir)))
    objects.at.script.start <- c(ls(), "objects.at.script.start")  ## Required for cleaning up workspace.
  #+END_SRC
* logDlogNPlotsBeforeAfterDataSelection.pdf
  #+NAME: logDlogNPlotsBeforeAfterDataSelection.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataSelection.tex
    ## This creates 4 plots in one file in a 2-by-2 layout (one row per species, one column per data selection state), showing the effect of the data selection mechanism.
    ## Plotting preamble.
    kPlotMargins <- c(3.5, 3.5, 1, 1)
    kPlotMgp <- c(2, 1, 0)
    kXLab <- expression(paste("log(", italic("D"), ")"))
    kYLab <- expression(paste("log(", italic("N"), ")"))
    kXMin <- list("beech" = 0.8,
	        "spruce" = 0.8)
    kXMax <- list("beech" = 1.8,
	        "spruce" = 1.8)
    kYMin <- list("beech" = 1.6,
	        "spruce" = 2.4 * 0.9)
    kYMax <- list("beech" = 3.6,
	        "spruce" = 3.6)
    kPlotLayout <- 1:4
    kUpperThresholdLineType <- "dashed"
    kLowerThresholdLineType <- "solid"
    kThresholdLinesFrom <- 0
    kThresholdLinesTo <- 10
    kThresholdLinesCol <- "black"
    ## Loop over all species names.
    ## for (cur.species.name in kSpeciesNames) {
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   ## "logDlogNPlotsBeforeAfterDataSelection",
		   ## kSpeciesNamesCapitalized[grep(pattern = cur.species.name, x = kSpeciesNamesCapitalized, ignore.case = TRUE)], ".pdf")
		   "logDlogNPlotsBeforeAfterDataSelection.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidth2by2,
        height = kPdfHeight2by2,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot margins.
    par("mar" = kPlotMargins)
    ## Set plot layout to 2-by-2.
    layout(mat = matrix(data = kPlotLayout,
		    ## nrow = 1,
		    nrow = 2,
		    ncol = 2,
		    ## byrow = FALSE))
		    byrow = TRUE))
    ## Loop over all plot numbers.
    for (cur.plot.nr in kPlotLayout) {
        ## Set current species name ("beech" for plots number 1 and 2, "spruce" for plots number 3 and 4).
        cur.species.name <- ifelse(test = cur.plot.nr <= 2,
			     yes = "beech",
			     no = "spruce")
        ## Extract x- and y-limits for current species.
        cur.xmin <- as.numeric(x = kXMin[names(x = kXMin) == cur.species.name])
        cur.xmax <- as.numeric(x = kXMax[names(x = kXMax) == cur.species.name])
        cur.ymin <- as.numeric(x = kYMin[names(x = kYMin) == cur.species.name])
        cur.ymax <- as.numeric(x = kYMax[names(x = kYMax) == cur.species.name])
        ## Set point and line color for current species.
        cur.point.line.col <- as.character(x = kSpeciesColors[names(x = kSpeciesColors) == cur.species.name])
        ## Set data frame version for current plot number ("1.0" for plots number 1 and 3, "1.8" for plots number 2 and 4).
        cur.data.frame.version <- ifelse(test = cur.plot.nr %% 2 != 0,
				 yes = "1.0",
				 no = "1.8")
        ## Get data frame for current species and plot number.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.", cur.data.frame.version))
        ## Select column specifier for current plot ("A" for plot number 1, "B" for plot number 2, "" for plots number 3 and 4).
        if (cur.plot.nr <=2) {
	  cur.plot.main <- ifelse(test = cur.plot.nr %% 2 != 0,
			      yes = "A",
			      no = "B")
        } else {
	  cur.plot.main <- ""
        }
        ## Set x-axis label for current plot ("" for plots number 1 and 2, kXLab for plots number 3 and 4).
        cur.xlab <- ifelse(test = cur.plot.nr <= 2,
		       yes = "",
		       no = kXLab)
        ## Set y-axis label for current plot (kYLab for plots number 1 and 3, "" for plots number 2 and 4).
        cur.ylab <- ifelse(test = cur.plot.nr %% 2 != 0,
		       yes = kYLab,
		       no = "")
        ## Initiate legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        legend.lwd <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
        ## Create empty plot.
        plot(x = 0,
	   type = "n",
	   xlim = c(cur.xmin, cur.xmax),
	   ylim = c(cur.ymin, cur.ymax),
	   ## xlab = kXLab,
	   xlab = cur.xlab,
	   ## ylab = kYLab,
	   ylab = cur.ylab,
	   xaxs = "i",
	   yaxs = "i",
	   mgp = kPlotMgp,
	   main = cur.plot.main,
	   panel.first = abline(v = seq(from = 0,
				  to = 2,
				  by = 0.2),
			    h = seq(from = 0,
				  to = 4,
				  by = 0.2),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Define function for calculating the lines representing the slope thresholds.
        slope.threshold.func <- function(s, x, k) {
	  res <- s * x + k
	  return(res)
        }
        ## Add line for upper slope threshold to plot.
        cur.species.upper.slope.threshold <- ifelse(test = cur.species.name == "beech",
					  yes = -0.9,
					  no = -0.65)
        cur.species.threshold.func.upper.intercept <- cur.ymax - cur.species.upper.slope.threshold * cur.xmin
        curve(expr = slope.threshold.func(s = cur.species.upper.slope.threshold,
				  x,
				  k = cur.species.threshold.func.upper.intercept),
	    from = kThresholdLinesFrom,
	    to = kThresholdLinesTo,
	    lty = kUpperThresholdLineType,
	    lwd = kLineWidth,
	    col = kThresholdLinesCol,
	    add = TRUE)
        ## Update legend components.
        legend.legend <- c(legend.legend, paste0("upper slope threshold ", cur.species.name))
        legend.pch <- c(legend.pch, NA)
        legend.lty <- c(legend.lty, kUpperThresholdLineType)
        legend.lwd <- c(legend.lwd, kLineWidth)
        legend.col <- c(legend.col, kThresholdLinesCol)
        ## Add line for lower slope threshold to plot.
        cur.species.lower.slope.threshold <- ifelse(test = cur.species.name == "beech",
					  yes = -2.91,
					  no = -2.82)
        cur.species.threshold.func.lower.intercept <- cur.ymax - cur.species.lower.slope.threshold * cur.xmin
        curve(expr = slope.threshold.func(s = cur.species.lower.slope.threshold,
				  x,
				  k = cur.species.threshold.func.lower.intercept),
	    from = kThresholdLinesFrom,
	    to = kThresholdLinesTo,
	    lty = kLowerThresholdLineType,
	    lwd = kLineWidth,
	    col = kThresholdLinesCol,
	    add = TRUE)
        ## Update legend components.
        legend.legend <- c(legend.legend,  paste0("lower slope threshold ", cur.species.name))
        legend.pch <- c(legend.pch, NA)
        legend.lty <- c(legend.lty, kLowerThresholdLineType)
        legend.lwd <- c(legend.lwd, kLineWidth)
        legend.col <- c(legend.col, kThresholdLinesCol)
        ## Loop over all "edvid"s.
        for (cur.edvid.name in levels(x = cur.data.frame[["edvid"]])) {
	  ## Extract x-values for current "edvid".
	  cur.x.values <- cur.data.frame[["log.dg"]][cur.data.frame[["edvid"]] == cur.edvid.name]
	  ## Extract y-values for current "edvid".
	  cur.y.values <- cur.data.frame[["log.nha"]][cur.data.frame[["edvid"]] == cur.edvid.name]
	  ## Add points to plot per "edvid", with distinct colors per species.
	  points(x = cur.x.values,
	         y = cur.y.values,
	         type = "p",
	         pch = kPointCharacter,
	         lty = kLineType,
	         col = cur.point.line.col)
	  ## Add lines to plot per "edvid", with distinct colors per species.
	  lines(x = cur.x.values,
	        y = cur.y.values,
	        lty = kLineType,
	        lwd = kLineWidth,
	        col = cur.point.line.col)
        }
        ## Calculate number of observations in current data frame.
        cur.n <- nrow(x = cur.data.frame)
        ## Calculate number of sample plots in current data frame.
        cur.sample.plots.n <- length(x = levels(x = droplevels(x = cur.data.frame[["edvid"]])))
        ## Update legend components. I am adding 2 elements to each legend component because it’s the only way to insert a line break between the string "Beobachtungen" and the expression containing "cur.n" and "cur.sample.plots.n".
        legend.legend <- c(legend.legend, paste0("observations ", cur.species.name))
        legend.pch <- c(legend.pch, kPointCharacter)
        legend.lty <- c(legend.lty, kLineType)
        legend.lwd <- c(legend.lwd, kLineWidth)
        legend.col <- c(legend.col, cur.point.line.col)
        legend.legend <- c(legend.legend,
		       mapply(FUN = function(expr1, numbr1, expr2, numbr2) { as.expression(x = bquote(.(expr1)*.(numbr1)*", "*.(expr2)*.(numbr2)*")")) },
			    expr1 = expression("("*italic("n")["obs"]*" = "),
			    numbr1 = cur.n,
			    expr2 = expression(italic("n")["sp"]*" = "),
			    numbr2 = cur.sample.plots.n
			    ))
        legend.pch <- c(legend.pch, NA)
        legend.lty <- c(legend.lty, NA)
        legend.lwd <- c(legend.lwd, NA)
        legend.col <- c(legend.col, NA)
        ## Add legend.
        legend(x = "bottomleft",
	     legend = legend.legend,
	     col = legend.col,
	     lty = legend.lty,
	     pch = legend.pch,
	     lwd = legend.lwd,
	     bg = "gray")
        ## Reset legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        legend.lwd <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
    }
    ## Turn off graphics device.
    graphics.off()
    ## }
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* LocationsSamplePlots.pdf
  #+NAME: LocationsSamplePlots.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## This block creates 2 plots (one per species) in one file in a 1-by-2 layout, showing the locations of the sample plots on a map of Germany.
    ## Plotting preamble.
    kPlotMargins <- c(0.5, 0.5, 0.5, 0.5)
    kPlotLayout <- 1:2
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "LocationsSamplePlots.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidth1by2,
        height = kPdfHeight1by2,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout to 1-by-2.
    layout(mat = matrix(data = kPlotLayout,
		    nrow = 1,
		    ncol = 2,
		    byrow = FALSE))
    ## Set plot margins.
    par("mar" = kPlotMargins)
    ## Initiate legend components.
    legend.legend <- vector(mode = "character")
    legend.pch <- vector(mode = "numeric")
    legend.col <- vector(mode = "character")
    ## Loop over all plot numbers.
    for (cur.plot.nr in kPlotLayout) {
        ## Set current species name ("beech" for plot number 1, "spruce" for plot number 2).
        cur.species.name <- ifelse(test = cur.plot.nr == 1,
			     yes = "beech",
			     no = "spruce")
        ## Set point and line color for current species.
        cur.point.line.col <- as.character(x = kSpeciesColors[names(x = kSpeciesColors) == cur.species.name])
        ## Get data frame for current species and plot number.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Condense "cur.data.frame" to the unique values of columns "edvid", "EAST.UTM", and "NORTH.UTM".
        cur.data.frame <- unique(x = cur.data.frame[, c("edvid", "EAST.UTM", "NORTH.UTM")])
        ## Extract easting and northing.
        easting <- cur.data.frame[["EAST.UTM"]]
        northing <- cur.data.frame[["NORTH.UTM"]]
        ## Calculate plot axis limits.
        x.lim.low <- range(easting, na.rm = TRUE)[1]
        x.lim.high <- range(easting, na.rm = TRUE)[2]
        y.lim.low <- range(northing, na.rm = TRUE)[1]
        y.lim.high <- range(northing, na.rm = TRUE)[2]
        x.lim <- c(x.lim.low, x.lim.high)
        y.lim <- c(y.lim.low, y.lim.high)
        ## Plot national and federal state boundaries.
        library("sp")
        plot(x = bld_utm,
	   add = FALSE,
	   lwd = kLineWidth)
        ## Add points at sample plot locations to plot.
        points(x = easting,
	     y = northing,
	     xlab = "Easting",
	     ylab = "Northing",
	     col = cur.point.line.col,
	     pch = kPointCharacter)
        ## Draw box around plot.
        box(bty = "o")
        ## Update legend components.
        legend.legend <- c(legend.legend, paste0("sample plots ", cur.species.name))
        legend.pch <- c(legend.pch, kPointCharacter)
        legend.col <- c(legend.col, cur.point.line.col)
        ## Add legend.
        legend(x = "bottomright",
	     legend = legend.legend,
	     pch = legend.pch,
	     col = legend.col,
	     bg = "gray")
        ## Reset legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* SpeciesAltitudeOfSamplePlots.pdf
  #+NAME: SpeciesAltitudeOfSamplePlots.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Plotting preamble.
    kPlotMargins <- c(3, 3, 0.5, 0.75)
    kPlotMgp <- c(2, 1, 0)
    kXValues <- seq(from = 1, to = 2, by = 0.5)
    kXMin <- min(kXValues)
    kXMax <- max(kXValues)
    kYMin <- min(bart.beech.clean.1.8[["hnn.neu"]],
	       bart.spruce.clean.1.8[["hnn.neu"]],
	       na.rm = TRUE)
    kYMax <- round(x = max(bart.beech.clean.1.8[["hnn.neu"]],
		       bart.spruce.clean.1.8[["hnn.neu"]],
		       na.rm = TRUE),
	         digits = -2)
    kYAxisTicks <- seq(from = 0,
		   to = kYMax,
		   by = 100)
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "SpeciesAltitudeOfSamplePlots.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidth1by1,
        height = kPdfHeight1by1,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot margins.
    par("mar" = kPlotMargins)
    ## Create empty plot.
    plot(x = kXValues,
         xlim = c(kXMin, kXMax),
         ylim = c(kYMin, kYMax),
         xlab = "Species",
         ylab = "Altitude above sea level [m]",
         mgp = kPlotMgp,
         type = "n",
         axes = FALSE,
         panel.first = abline(h = kYAxisTicks,
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			col = kGridLineCol))
    axis(side = 1,
         labels = kSpeciesNamesCapitalized,
         at = c(1, 2))
    axis(side = 2,
         labels = TRUE,
         at = seq(from = kYAxisTicks[1],
	        to = kYAxisTicks[length(x = kYAxisTicks)],
	        by = 200))
    ## Draw box around plot.
    box(bty = "o")
    ## Initiate legend components.
    legend.legend <- vector(mode = "character")
    legend.col <- vector(mode = "character")
    legend.pch <- vector(mode = "numeric")
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get point color for current species.
        cur.point.color <- kSpeciesColors[[cur.species.name]]
        ## Get data frame for current species.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Make data frame unique with respect to columns "edvid" and "hnn.neu".
        cur.data.frame.unique <- unique(x = cur.data.frame[, c("edvid", "hnn.neu")])
        ## Add points to plot.
        points(x = rep(x = which(x = kSpeciesNames == cur.species.name), times = length(x = cur.data.frame.unique[["hnn.neu"]])),
	     y = cur.data.frame.unique[["hnn.neu"]],
	     col = cur.point.color,
	     pch = kPointCharacter)
        ## Update legend components.
        legend.legend <- c(legend.legend, paste0("sample plots ", cur.species.name))
        legend.col <- c(legend.col, cur.point.color)
        legend.pch <- c(legend.pch, kPointCharacter)
    }
    ## Add legend.
    legend(x = "topleft",
	 legend = legend.legend,
	 pch = legend.pch,
	 col = legend.col,
	 bg = kLegendBg)
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* StandAgeTopHeightYieldClassClassification.pdf
** General procedure:
   1. Set SI.h100 values per yield class based on Schober (1995) (moderate thinning).
   2. Generate a sequence of SI.h100 values from the worst yield class to the best yield class needed to cover the observed range of SI.h100 values, with a distance of 0.1 between sequence elements.
   3. Generate a color palette based on the result of 2.
   4. Map the observed SI.h100 values to the corresponding color of the color palette from 3. for plotting.
   5. Map the SI.h100 value of each yield class to the corresponding color of the color palette from 3. for the legend.
** R Code
   #+NAME: StandAgeTopHeightYieldClassClassification.pdf
   #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
     ## Plotting preamble.
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kLegendX <- "bottomright"
     kXLim <- c(0, 160)
     kYLim <- c(0, 40)
     ## Define color palette generating function.
     kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
     ## Set best yield class level for which to interpolate SI.h100 values
     kBestYieldClassLevel <- -2
     ## Turn off graphics device.
     graphics.off()
     ## Create file name.
     file.name <-paste0(kGraphicsSubdir,
		    "StandAgeTopHeightYieldClassClassification.pdf")
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = file.name,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.85,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over all species names.
     for (cur.species.name in kSpeciesNames) {
         ## Get data frame for current species.
         bart.cur.species.clean.1.8 <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
         ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
         SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
					"SI.h100" = NA)
         ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
         if (cur.species.name == "beech") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
         }
         if (cur.species.name == "spruce") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
         }
         ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
         for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	   SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	   SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
         }
         ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
         SI.h100.min <- min(bart.cur.species.clean.1.8[["SI.h100"]],
		        na.rm = TRUE)
         SI.h100.max <- max(bart.cur.species.clean.1.8[["SI.h100"]],
		        na.rm = TRUE)
         index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
         index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
         ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
         SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				   to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				   by = 0.1),
			     digits = 1)
         ## Generate a color palette of the same length as "SI.h100.sequence".
         cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Create empty plot.
         plot(x = bart.cur.species.clean.1.8[["alt"]],
	    type = "n",
	    xlim = kXLim,
	    ylim = kYLim,
	    xlab = "Stand age [a]",
	    ylab = expression(italic("h")[100]*" [m]"),,
	    main = kSpeciesNamesCapitalized[[cur.species.name]],
	    mgp = kPlotMgp,
	    xaxs = "i",
	    yaxs = "i",
	    panel.first = abline(v = seq(from = kXLim[1],
				   to = kXLim[2],
				   by = 10),
			     h  = seq(from = kYLim[1],
				    to = kYLim[2],
				    by = 5),
			     lty = kGridLineType,
			     lwd = kGridLineWidth,
			     col = kGridLineCol))
         ## Loop over all evdids.
         for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	   ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	   edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			      subset = edvid == cur.edvid)
	   ## Add lines for observations belonging to current edvid.
	   lines(x =edvid.subset[["alt"]],
	         y = edvid.subset[["h100"]],
	         lwd = kLineWidth,
	         lty = kLineType)
         }
         ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
         for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	   ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	   edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			      subset = edvid == cur.edvid)
	   ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	   SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
					table = SI.h100.sequence)
	   ## Add points to plot.
	   points(x = edvid.subset[["alt"]],
		y = edvid.subset[["h100"]],
		col = cur.species.color.palette[SI.h100.rounded.color.index],
		pch = kPointCharacter)
         }
         ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
         SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						       digits = 1),
				      table = SI.h100.sequence)
         ## Add legend.
         legend.legend <- c(paste0("yield class ",
			     SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
         legend.col <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
         legend.pch <- kPointCharacter
         legend(x = kLegendX,
	      legend = legend.legend,
	      col = legend.col,
	      pch = legend.pch,
	      bg = kLegendBg)
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.                                   
     rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
* ObservationsCountPerEdvidSPECIES.txt
  #+NAME: ObservationsCountPerEdvidSPECIES.txt
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Extract capitalized version of current species name.
        cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
        ## Get data frame for current species.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Create a subset with only columns "edvid", "h100.EKL.I", and "SI.h100.diff.EKL.I".
        cur.data.frame <- subset(x = cur.data.frame, select = c("edvid", "h100.EKL.I", "SI.h100.diff.EKL.I"))
        ## Count observations per edvid.
        obs.per.edvid <- table(cur.data.frame[["edvid"]])
        ## Store results in data frame.
        cur.species.results.df <- data.frame("edvid" = names(x = obs.per.edvid),
				     "observations.count" = as.numeric(x = obs.per.edvid),
				     stringsAsFactors = FALSE)
        ## Calculate sum of each column.
        cur.species.results.df <- rbind(cur.species.results.df,
				data.frame("edvid" = c(as.character(x = nrow(x = cur.species.results.df)),
						   NA,
						   NA,
						   NA,
						   NA),
					 "observations.count" = c(sum(cur.species.results.df[["observations.count"]]),
							      min(cur.species.results.df[["observations.count"]]),
							      mean(cur.species.results.df[["observations.count"]]),
							      median(cur.species.results.df[["observations.count"]]),
							      max(cur.species.results.df[["observations.count"]]))
					 ))
        ## Set rownames.
        rownames(x = cur.species.results.df) <- c(rownames(x = cur.species.results.df)[1:(length(x = rownames(x = cur.species.results.df)) - 5)],
					"total",
					"min",
					"mean",
					"median",
					"max")
        ## Round column "observations.count" to 1 decimal digit.
        cur.species.results.df[["observations.count"]] <- round(x = cur.species.results.df[["observations.count"]],
						    digits = 1)
        ## Store printing of "cur.species.results.df" in "cur.output", while left justifying output.
        cur.output <- capture.output(print(x = format(x = cur.species.results.df,
					    justify="left",
					    scientific = FALSE),
				   row.names = TRUE))
        ## Output results to file.
        cat(cur.output,
	  file = paste0(kOutputSubdir, "ObservationsCountPerEdvid", cur.species.name.capitalized, ".txt"),
	  sep = "\n",
	  fill = FALSE)
    }
    ## Clean up workspace.                                   
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* StandAgeBasalAreaYieldClassClassification.pdf
  #+NAME: StandAgeBasalAreaYieldClassClassification.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Plotting preamble.
    kPlotMargins <- c(3, 3.25, 2, 1)
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:2,
		      nrow = 2,
		      ncol = 1)
    kLegendX <- "topright"
    kXLim <- c(0, 160)
    kYLim <- c(0, 85)
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "StandAgeBasalAreaYieldClassClassification.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidthA4Portrait,
        height = kPdfHeightA4Portrait * 0.85,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get data frame for current species.
        bart.cur.species.clean.1.8 <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
        SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				         "SI.h100" = NA)
        ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
        if (cur.species.name == "beech") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
        }
        if (cur.species.name == "spruce") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
        }
        ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
        for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	  SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	  SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
        }
        ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
        SI.h100.min <- min(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        SI.h100.max <- max(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
        index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
        ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
        SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				  to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				  by = 0.1),
			    digits = 1)
        ## Generate a color palette of the same length as "SI.h100.sequence".
        cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
        ## Set plot margins.
        par("mar" = kPlotMargins)
        ## Create empty plot.
        plot(x = bart.cur.species.clean.1.8[["alt"]],
	   type = "n",
	   xlim = kXLim,
	   ylim = kYLim,
	   xlab = "Stand age [a]",
	   ylab = expression(italic("G")*" [m"^2*" ha"^-1*"]"),
	   main = kSpeciesNamesCapitalized[[cur.species.name]],
	   mgp = kPlotMgp,
	   xaxs = "i",
	   yaxs = "i",
	   panel.first = abline(v = seq(from = kXLim[1],
				  to = kXLim[2],
				  by = 10),
			    h  = seq(from = kYLim[1],
				   to = kYLim[2],
				   by = 10),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Loop over all evdids.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Add lines for observations belonging to current edvid.
	  lines(x =edvid.subset[["alt"]],
	        y = edvid.subset[["gha"]],
	        lwd = kLineWidth,
	        lty = kLineType)
        }
        ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	  SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				         table = SI.h100.sequence)
	  ## Add points to plot.
	  points(x = edvid.subset[["alt"]],
	         y = edvid.subset[["gha"]],
	         col = cur.species.color.palette[SI.h100.rounded.color.index],
	         pch = kPointCharacter)
        }
        ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
        SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						      digits = 1),
					      table = SI.h100.sequence)
        ## Add legend.
        legend.legend <- c(paste0("yield class ",
			    SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        legend.col <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
        legend.pch <- kPointCharacter
        legend(x = kLegendX,
	     legend = legend.legend,
	     col = legend.col,
	     pch = legend.pch,
	     bg = kLegendBg)
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* StandAgeProductivityIndexYieldClassClassification.pdf
  #+NAME: StandAgeProductivityIndexYieldClassClassification.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Plotting preamble.
    kPlotMargins <- c(3, 3.25, 2, 1)
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:2,
		      nrow = 2,
		      ncol = 1)
    kLegendX <- "topright"
    kLegendNCol <- 2
    kYieldClassSIValuesLineType <- "dashed"
    kXLim <- c(0, 160)
    kYLim <- c(20, 50)
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "StandAgeProductivityIndexYieldClassClassification.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidthA4Portrait,
        height = kPdfHeightA4Portrait * 0.85,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get data frame for current species.
        bart.cur.species.clean.1.8 <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
        SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				         "SI.h100" = NA)
        ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
        if (cur.species.name == "beech") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
        }
        if (cur.species.name == "spruce") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
        }
        ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
        for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	  SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	  SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
        }
        ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
        SI.h100.min <- min(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        SI.h100.max <- max(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
        index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
        ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
        SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				  to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				  by = 0.1),
			    digits = 1)
        ## Generate a color palette of the same length as "SI.h100.sequence".
        cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
        ## Initiate legend components.
        legend.legend <- vector(mode = "expression")
        legend.col <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        ## Set plot margins.
        par("mar" = kPlotMargins)
        ## Create empty plot.
        plot(x = bart.cur.species.clean.1.8[["alt"]],
	   type = "n",
	   xlim = kXLim,
	   ylim = kYLim,
	   xlab = "Stand age [a]",
	   ylab = expression(italic("PI")*" [m]"),
	   main = kSpeciesNamesCapitalized[[cur.species.name]],
	   mgp = kPlotMgp,
	   xaxs = "i",
	   yaxs = "i",
	   panel.first = abline(v = seq(from = kXLim[1],
				  to = kXLim[2],
				  by = 10),
			    ## h  = seq(from = kYLim[1],
			    ## to = kYLim[2],
			    ## by = 5),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
        SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						      digits = 1),
					      table = SI.h100.sequence)
        ## Add horizontal lines at the central value of each yield class.
        abline(h = SI.h100.yield.class.values[["SI.h100"]][index.worst.yield.class.needed:index.best.yield.class.needed],
	     col = cur.species.color.palette[SI.h100.yield.class.values.color.index],
	     lty = kYieldClassSIValuesLineType)
        ## Update legend components.
        legend.legend <- c(legend.legend,
		       mapply(FUN = function(expr, numbr1, numbr2) { as.expression(x = bquote(.(expr)*.(numbr1)*" ("*.(numbr2)*" m)")) },  ## See https://stackoverflow.com/questions/27275798/combining-vector-variables-in-r-expression-for-plot-text?noredirect=1.
			    expr = expression(italic("PI")*" yield class "),
			    numbr1 = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"],
			    numbr2 = SI.h100.yield.class.values[["SI.h100"]][index.worst.yield.class.needed:index.best.yield.class.needed])
    )
        legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
        legend.pch <- c(legend.pch, rep(x = NA,
				times = length(x = SI.h100.yield.class.values.color.index)))
        legend.lty <- c(legend.lty, rep(x = kYieldClassSIValuesLineType,
				times = length(x = SI.h100.yield.class.values.color.index)))
        ## Loop over all evdids.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Add lines for observations belonging to current edvid.
	  lines(x =edvid.subset[["alt"]],
	        y = edvid.subset[["SI.h100"]],
	        lwd = kLineWidth,
	        lty = kLineType)
        }
        ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	  SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				         table = SI.h100.sequence)
	  ## Add points to plot.
	  points(x = edvid.subset[["alt"]],
	         y = edvid.subset[["SI.h100"]],
	         col = cur.species.color.palette[SI.h100.rounded.color.index],
	         pch = kPointCharacter)
        }
        ## Update legend components.
        legend.legend <- c(legend.legend, paste0("observations yield class ",
				         SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
        legend.pch <- c(legend.pch, rep(x = kPointCharacter,
				times = length(x = SI.h100.yield.class.values.color.index)))
        legend.lty <- c(legend.lty, rep(x = NA,
				times = length(x = SI.h100.yield.class.values.color.index)))
        ## Add legend.
        legend(x = kLegendX,
	     ncol = kLegendNCol,
	     legend = legend.legend,
	     col = legend.col,
	     pch = legend.pch,
	     bg = kLegendBg,
	     lty = legend.lty)
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* VariablesStatisticsSPECIES.txt
  #+NAME: StatisticsOfVariablesSPECIES.txt
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Preamble.
    kVariablesColumnNames <- c("alt",  ## All variables must be numeric.
			 "h100",
			 "gha",
			 "SI.h100",
			 "hnn.neu",
			 "Reineke.slope",
			 "h100.EKL.I",
			 "SI.h100.diff.EKL.I",
			 "sample.plot.mean.age")
    kStatisticFunctionsNames <- c("min",  ## All functions need to accept argument "x" as their input and argument "na.rm = TRUE".
			    "median",
			    "mean",
			    "max",
			    "span",
			    "mean.uniques")
    kRoundDigits <- c("Reineke.slope" = 3)
    span <- function(x, na.rm = TRUE) {
        var.min <- min(x = x,
		   na.rm = na.rm)
        var.max <- max(x = x,
		   na.rm = na.rm)
        res <- var.max - var.min
        return(res)
    }
    mean.uniques <- function(x, na.rm = TRUE) {
        x.unique <- unique(x = x)
        res <- mean(x = x.unique,
		na.rm = na.rm)
    }
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Initiate list in which to store results for current species.
        cur.species.results.list <- vector(mode = "list")
        ## Extract capitalized version of current species name.
        cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
        ## Loop over the names of all appropriate data frames.
        data.frame.names <- ls(pattern = paste0("bart.", cur.species.name, ".clean.1.[08]"))
        for (cur.data.frame.name in data.frame.names) {
	  ## Get current data frame for current species.
	  cur.data.frame <- get(x = cur.data.frame.name)
	  ## Initiate object in which to store results for current data frame.
	  cur.data.frame.results.df <- data.frame(matrix(data = NA,
					         nrow = length(x = kStatisticFunctionsNames),
					         ncol = 1 + length(x = kVariablesColumnNames)))
	  colnames(x = cur.data.frame.results.df) <- c("statistic", kVariablesColumnNames)
	  cur.data.frame.results.df[["statistic"]] <- kStatisticFunctionsNames
	  ## Loop over all column names of the variables of interest.
	  for (cur.col.name in kVariablesColumnNames) {
	      ## Loop over all statistic function names.
	      for (cur.stat.fun.name in kStatisticFunctionsNames) {
		## Get current statistic function.
		cur.stat.fun <- get(x = cur.stat.fun.name)
		## If a number of decimal digits for rounding has been set for the current column, use that, otherwise set it to 1.
		if (cur.col.name %in% names(x = kRoundDigits)) {
		    cur.round.digits <- kRoundDigits[[cur.col.name]]
		} else {
		    cur.round.digits <- 1
		}
		## Calclulate current statistic and store it in the appropriate row and column of "cur.data.frame.results.df".
		cur.data.frame.results.df[cur.data.frame.results.df[["statistic"]] == cur.stat.fun.name, cur.col.name] <- round(x = cur.stat.fun(x = cur.data.frame[[cur.col.name]],
														         na.rm = TRUE),
													  digits = cur.round.digits)
	      }}
	  ## Append "cur.data.frame.results.df" to "cur.species.results.list".
	  if (length(x = cur.species.results.list) == 0) {
	      cur.species.results.list <- list(cur.data.frame.results.df)
	  } else {
	      cur.species.results.list <- c(cur.species.results.list,
				      list(cur.data.frame.results.df))
	  }}
        ## Set names of "cur.species.results.list".
        names(x = cur.species.results.list) <- data.frame.names
        ## Store printing of "cur.species.results.list" in "cur.output", while left justifying output.
        cur.output <- capture.output(print(x = cur.species.results.list,
				   row.names = TRUE))
        ## Output results to file.
        cat(cur.output,
	  file = paste0(kOutputSubdir, "VariablesStatistics", cur.species.name.capitalized, ".txt"),
	  sep = "\n",
	  fill = FALSE)
    }
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* StandAgeStandAgeVariableYieldClassClassification.pdf
  #+NAME: StandAgeStandAgeVariableYieldClassClassification.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Plotting preamble.
    kPlotMargins <- c(3, 3.25, 2, 1)
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:2,
		      nrow = 2,
		      ncol = 1)
    kLegendX <- "bottomright"
    kXLim <- c(0, 160)
    kYLim <- c(0, 40)
    kCurveCol <- "black"
    kCurveLty <- "solid"
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "StandAgeStandAgeVariableYieldClassClassification.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidthA4Portrait,
        height = kPdfHeightA4Portrait * 0.85,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Initiate legend components.
        legend.legend <- vector(mode = "expression")
        legend.col <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        ## Get data frame for current species.
        bart.cur.species.clean.1.8 <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
        SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				         "SI.h100" = NA)
        ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
        if (cur.species.name == "beech") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
        }
        if (cur.species.name == "spruce") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
        }
        ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
        for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	  SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	  SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
        }
        ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
        SI.h100.min <- min(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        SI.h100.max <- max(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
        index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
        ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
        SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				  to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				  by = 0.1),
			    digits = 1)
        ## Generate a color palette of the same length as "SI.h100.sequence".
        cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
        ## Set plot margins.
        par("mar" = kPlotMargins)
        ## Create empty plot.
        plot(x = bart.cur.species.clean.1.8[["alt"]],
	   type = "n",
	   xlim = kXLim,
	   ylim = kYLim,
	   xlab = "Stand age [a]",
	   ylab = expression(italic("h")[100]*"("*italic("x")*")"["I. YC"]*" [m]"),
	   main = kSpeciesNamesCapitalized[[cur.species.name]],
	   mgp = kPlotMgp,
	   xaxs = "i",
	   yaxs = "i",
	   panel.first = abline(v = seq(from = kXLim[1],
				  to = kXLim[2],
				  by = 10),
			    h  = seq(from = kYLim[1],
				   to = kYLim[2],
				   by = 5),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Add curve for the function calculating the stand age variable.
        curve(expr = CalculateStandAgeVariable(age = x,
				       piyc1= PI1.YC[[cur.species.name]],
				       b0 = beta0[[cur.species.name]],
				       b1 = beta1[[cur.species.name]],
				       b2 = beta2[[cur.species.name]],
				       b3 = beta3[[cur.species.name]],
				       b4 = beta4[[cur.species.name]]),
	    from = kXLim[1],
	    to = kXLim[2],
	    col = kCurveCol,
	    lty = kCurveLty,
	    add = TRUE)
        ## Update legend components.
        legend.legend <- c(legend.legend,
		       "function curve")
        legend.col <- c(legend.col,
		    kCurveCol)
        legend.lty <- c(legend.lty,
		    kCurveLty)
        legend.pch <- c(legend.pch,
		    NA)
        ## Loop over all evdids.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Add lines for observations belonging to current edvid.
	  ## lines(x =edvid.subset[["alt"]],
	  ## y = edvid.subset[["h100.EKL.I"]],
	  ## lwd = kLineWidth,
	  ## lty = kLineType)
        }
        ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	  SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				         table = SI.h100.sequence)
	  ## Add points to plot.
	  points(x = edvid.subset[["alt"]],
	         y = edvid.subset[["h100.EKL.I"]],
	         col = cur.species.color.palette[SI.h100.rounded.color.index],
	         pch = kPointCharacter)
        }
        ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
        SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						      digits = 1),
					      table = SI.h100.sequence)
        ## Update legend components.
        legend.legend <- c(legend.legend,
		       paste0("observations yield class ",
			    SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        legend.col <- c(legend.col,
		    cur.species.color.palette[SI.h100.yield.class.values.color.index])
        legend.pch <- c(legend.pch,
		    rep(x = kPointCharacter,
		        times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        legend.lty <- c(legend.lty,
		    rep(x = NA,
		        times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        ## Add legend.
        ## legend.legend <- c(paste0("observation yield class ",
			    ## SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        ## legend.col <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
        ## legend.pch <- kPointCharacter
        legend(x = kLegendX,
	     legend = legend.legend,
	     lty = legend.lty,
	     col = legend.col,
	     pch = legend.pch,
	     bg = kLegendBg)
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* StandAgeProductivityIndexVariableYieldClassClassification.pdf
  #+NAME: StandAgeProductivityIndexVariableYieldClassClassification.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Plotting preamble.
    kPlotMargins <- c(3, 3.25, 2, 1)
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:2,
		      nrow = 2,
		      ncol = 1)
    kLegendX <- "topright"
    kXLim <- c(0, 160)
    kYLim <- c(-12.5, 12.5)
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "StandAgeProductivityIndexVariableYieldClassClassification.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidthA4Portrait,
        height = kPdfHeightA4Portrait * 0.85,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get data frame for current species.
        bart.cur.species.clean.1.8 <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
        SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				         "SI.h100" = NA)
        ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
        if (cur.species.name == "beech") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
        }
        if (cur.species.name == "spruce") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
        }
        ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
        for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	  SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	  SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
        }
        ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
        SI.h100.min <- min(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        SI.h100.max <- max(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
        index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
        ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
        SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				  to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				  by = 0.1),
			    digits = 1)
        ## Generate a color palette of the same length as "SI.h100.sequence".
        cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
        ## Set plot margins.
        par("mar" = kPlotMargins)
        ## Create empty plot.
        plot(x = bart.cur.species.clean.1.8[["alt"]],
	   type = "n",
	   xlim = kXLim,
	   ylim = kYLim,
	   xlab = "Stand age [a]",
	   ylab = expression(italic("PI")["diff"]*" [m]"),
	   main = kSpeciesNamesCapitalized[[cur.species.name]],
	   mgp = kPlotMgp,
	   xaxs = "i",
	   yaxs = "i",
	   panel.first = abline(v = seq(from = kXLim[1],
				  to = kXLim[2],
				  by = 10),
			    h  = seq(from = round(x = kYLim[1],
					     digits = -1),
				   to = round(x = kYLim[2],
					   digits = -1),
				   by = 2.5),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Loop over all evdids.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Add lines for observations belonging to current edvid.
	  lines(x =edvid.subset[["alt"]],
	        y = edvid.subset[["SI.h100.diff.EKL.I"]],
	        lwd = kLineWidth,
	        lty = kLineType)
        }
        ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	  SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				         table = SI.h100.sequence)
	  ## Add points to plot.
	  points(x = edvid.subset[["alt"]],
	         y = edvid.subset[["SI.h100.diff.EKL.I"]],
	         col = cur.species.color.palette[SI.h100.rounded.color.index],
	         pch = kPointCharacter)
        }
        ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
        SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						      digits = 1),
					      table = SI.h100.sequence)
        ## Add legend.
        legend.legend <- c(paste0("yield class ",
			    SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        legend.col <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
        legend.pch <- kPointCharacter
        legend(x = kLegendX,
	     legend = legend.legend,
	     col = legend.col,
	     pch = legend.pch,
	     bg = kLegendBg)
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* ProductivityIndexVariableCounts.txt
  #+NAME: ProductivityIndexVariableCounts.txt
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Preamble.
    res.df.col.names <- c("Species",
		      "n.SI.h100.diff.EKL.I.geq.0",
		      "n.SI.h100.diff.EKL.I.less.0")
    ## Create data frame in which to store results for output.
    res.df <- data.frame(matrix(data = NA,
			  nrow = length(x = kSpeciesNames),
			  ncol = length(x = res.df.col.names)))
    colnames(x = res.df) <- res.df.col.names
    ## Set species names in "res.df".
    res.df[["Species"]] <- kSpeciesNamesCapitalized
    ## Loop over species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get capitalized species name.
        cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
        ## Get data frame for current species.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Count occurrence of SI.h100.diff.EKL.I >= 0.
        res.df[res.df[["Species"]] == cur.species.name.capitalized, "n.SI.h100.diff.EKL.I.geq.0"] <- length(x = which(x = cur.data.frame[["SI.h100.diff.EKL.I"]] >= 0))
        ## Count occurrence of SI.h100.diff.EKL.I < 0.
        res.df[res.df[["Species"]] == cur.species.name.capitalized, "n.SI.h100.diff.EKL.I.less.0"] <- length(x = which(x = cur.data.frame[["SI.h100.diff.EKL.I"]] < 0))
    }
    ## Store printing of "res.df" in "output", while left justifying output.
    output <- capture.output(print(x = format(x = res.df,
				      justify="left",
				      scientific = FALSE),
			     row.names = TRUE))
    ## Output results to file.
    cat(output,
        file = paste0(kOutputSubdir, "ProductivityIndexVariableCounts.txt"),
        sep = "\n",
        fill = FALSE)
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* CorrelationCoefficients.txt
  #+NAME: CorrelationCoefficients.txt
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Preamble.
    kNamesOfColumnsToEvaluate <- c("alt", "SI.h100.diff.EKL.I", "h100.EKL.I")
    ## Initiate list in which to store results for all species.
    results.list <- vector(mode = "list")
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Initiate data frame in which to store results of current species.
        cur.species.results.df <- data.frame(matrix(data = NA,
					  nrow = length(x = kNamesOfColumnsToEvaluate),
					  ncol = length(x = kNamesOfColumnsToEvaluate)))
        colnames(x = cur.species.results.df) <- kNamesOfColumnsToEvaluate
        rownames(x = cur.species.results.df) <- kNamesOfColumnsToEvaluate
        ## Get source data frame for current species.
        cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Loop over all rows in "cur.species.results.df".
        for (cur.row.index in seq_len(length.out = nrow(x = cur.species.results.df))) {
	  ## Loop over all columns in "cur.species.results.df".
	  for (cur.col.index in seq_len(length.out = ncol(x = cur.species.results.df))) {
	      ## Calclulate correlation coefficient between source data frame columns of interest.
	      cur.x.col.name <- colnames(x = cur.species.results.df)[cur.col.index]
	      cur.y.col.name <- rownames(x = cur.species.results.df)[cur.row.index]
	      cur.cor <- cor(x = cur.data.frame[[cur.x.col.name]],
			 y = cur.data.frame[[cur.y.col.name]])
	      ## Store result in appropriate cell of "cur.species.results.df".
	      cur.species.results.df[cur.row.index, cur.col.index] <- cur.cor
	  }}
        ## Append "cur.species.results.df" to "results.list".
        if (length(x = results.list) == 0) {
	  results.list <- list(cur.species.results.df)
        } else {
	  results.list <- c(results.list,
			list(cur.species.results.df))
        }}
    ## Set names of "results.list".
    names(x = results.list) <- kSpeciesNamesCapitalized
    ## Store printing of "results.list" in "cur.output", while left justifying output.
    cur.output <- capture.output(print(x = results.list,
			         row.names = TRUE))
    ## Output results to file.
    cat(cur.output,
        file = paste0(kOutputSubdir, "CorrelationCoefficients.txt"),
        sep = "\n",
        fill = FALSE)
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* ConversionStandAgeStandAgeVariable.txt
  #+NAME: ConversionStandAgeStandAgeVariable.txt
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/GAM1Results.tex
    ## Create age vector.
    age <- 1:160
    ## Initiate data frame in which to store results for all species.
    results.df <- data.frame(matrix(data = NA,
			      nrow = length(x = age),
			      ncol = length(x = kSpeciesNames) + 1))
    colnames(x = results.df) <- c("age", kSpeciesNames)
    results.df[["age"]] <- age
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Calculate stand age variable corresponding to "age" for current species.
        cur.stand.age.var <- CalculateStandAgeVariable(age = age,
					     piyc1 = PI1.YC[[cur.species.name]],
					     b0 = beta0[[cur.species.name]],
					     b1 = beta1[[cur.species.name]],
					     b2 = beta2[[cur.species.name]],
					     b3 = beta3[[cur.species.name]],
					     b4 = beta4[[cur.species.name]])
        ## Store "cur.stand.age.var" in the appropriate row of "results.df". 
        results.df[[cur.species.name]] <- cur.stand.age.var
    }
    ## Store printing of "results.df" in "output", while left justifying output.
    output <- capture.output(print(x = format(x = results.df,
				      justify="left",
				      scientific = FALSE),
			     row.names = TRUE))
    ## Output results to file.
    cat(output,
        file = paste0(kOutputSubdir, "ConversionStandAgeStandAgeVariable.txt"),
        sep = "\n",
        fill = FALSE)
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* GAM1
** GAM1Preamble
   #+NAME: GAM1Preamble
   #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
     ## Modelling preamble ##
     library(package = "mgcv", character.only = TRUE)
     kModelID <- "GAM1"
     kDistFamily <- Gamma(link = "log")
     cur.formula <- kFormulas[[kModelID]]
     kGraphicsSubsubdir <- paste0(kGraphicsSubdir, kModelID, "/")
     objects.at.script.start <- c(objects.at.script.start,
			    "kModelID",
			    "kDistFamily",
			    "cur.formula",
			    "kGraphicsSubsubdir")
     system2(command = "mkdir",
	   args = paste0("-p ", kGraphicsSubsubdir))
   #+END_SRC
** GAM1EffectStandAgeVariable.pdf
   #+NAME: GAM1EffectStandAgeVariable.pdf
   #+BEGIN_SRC R :results silent :var input=GAM1Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/GAM1Results.tex
     ## Preamble.
     kPredictorVariableRName <- kStandAgeVariableRName
     kPredictorVariableMathName <- kStandAgeVariableMathName
     kTermNumber <- 1
     ## Plotting preamble.
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kXLim <- c(0, 40)
     kYLim <- c(-3, 1)
     kGridIntervalV <- 2.5
     kGridIntervalH <- 0.5
     kGridDigitsV <- -1
     kGridDigitsH <- 1
     kRugTicksize <- 0.05
     kRugLwd <- 0.5
     kRugCol <- "gray"
     kRugCol <- "black"
     kRugLine <- -0.5
     kConfidenceBandShadeCol <- "gray"
     kLegendX <- "topleft"
     ## Create filename.
     file.name <- paste0(kGraphicsSubsubdir,
		     paste0(kModelID, "EffectStandAgeVariable.pdf"))
     ## Turn off graphics device.
     graphics.off()
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = file.name,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.90,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over all species names.
     for (cur.species.name in kSpeciesNames) {
         ## Initiate legend components.
         legend.legend <- vector(mode = "expression")
         legend.col <- vector(mode = "character")
         legend.pch <- vector(mode = "numeric")
         legend.lty <- vector(mode = "character")
         ## Get capitalized name for current species.
         cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
         ## Get data frame for current species, restricted to only the dependent and predictor variables, omitting NAs.
         cur.data.frame <- na.omit(object = subset(x = get(x = paste0("bart.", cur.species.name, ".clean.1.8")),
					 select = c(kDependentVariableRName,
						  kStandAgeVariableRName,
						  kProductivityIndexVariableRName)))
         ## Fit model.
         cur.model <- gam(formula = cur.formula,
		      data = cur.data.frame,
		      family = Gamma(link = "log"),
		      na.action = na.omit)
         ## Extract edf of smooth term.
         edf.smooth.term <- round(x = pen.edf(x = cur.model)[grepl(x = names(x = pen.edf(x = cur.model)), pattern = kPredictorVariableRName)], digits = 2)
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Plot term effect.
         plot.gam(x = cur.model,
	        rug = FALSE,
	        all.terms = TRUE,
	        select = kTermNumber,
	        main = cur.species.name.capitalized,
	        pages = 0,
	        shade = FALSE,
	        shade.col = kConfidenceBandShadeCol,
	        mgp = kPlotMgp,
	        xlim = kXLim,
	        ylim = kYLim,
	        xaxs = "i",
	        yaxs = "i",
	        xlab = as.expression(x = bquote(expr = .(kPredictorVariableMathName)*" [m]")),
	        ylab = as.expression(x = bquote(expr = italic("s")*"("*.(kPredictorVariableMathName)*", "*.(edf.smooth.term)*")")),
	        panel.first = abline(v = seq(from = round(x = kXLim[1],
						digits = kGridDigitsV),
				       to = round(x = kXLim[2],
					        digits = kGridDigitsV),
				       by = kGridIntervalV),
			         h  = seq(from = round(x = kYLim[1],
						 digits = kGridDigitsH),
				        to = round(x = kYLim[2],
					         digits = kGridDigitsH),
				        by = kGridIntervalH),
			         lty = kGridLineType,
			         lwd = kGridLineWidth,
			         col = kGridLineCol))
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        expression(""%+-%" standard error"),
		        "estimated effect")
         legend.col <- c(legend.col,
		     "black")
         legend.lty <- c(legend.lty,
		     "dashed",
		     "solid")
         ## Add rug.
         rug(x = cur.data.frame[[kPredictorVariableRName]],
	   ticksize = kRugTicksize,
	   side = 1,
	   lwd = kRugLwd,
	   col = kRugCol,
	   line = kRugLine)
         ## Draw box around plot.
         box(bty = "o")
         ## Add legend.
         legend(x = kLegendX,
	      legend = legend.legend,
	      lty = legend.lty,
	      col = legend.col,
	      bg = kLegendBg)
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.
     rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
** GAM1EffectProductivityIndexVariable.pdf
   #+NAME: GAM1EffectProductivityIndexVariable.pdf
   #+BEGIN_SRC R :results silent :var input=GAM1Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/GAM1Results.tex
     ## Preamble.
     kPredictorVariableRName <- kProductivityIndexVariableRName
     kPredictorVariableMathName <- kProductivityIndexVariableMathName
     kTermNumber <- 2
     ## Plotting preamble.
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kXLim <- c(-12.5, 12.5)
     kYLim <- c(-4, 1)
     kGridIntervalV <- 2.5
     kGridIntervalH <- 0.5
     kGridDigitsV <- -1
     kGridDigitsH <- 1
     kRugTicksize <- 0.05
     kRugLwd <- 0.5
     kRugCol <- "gray"
     kRugCol <- "black"
     kRugLine <- -0.5
     kConfidenceBandShadeCol <- "gray"
     kLegendX <- "topleft"
     ## Create filename.
     file.name <- paste0(kGraphicsSubsubdir,
		     paste0(kModelID, "EffectProductivityIndexVariable.pdf"))
     ## Turn off graphics device.
     graphics.off()
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = file.name,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.90,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over all species names.
     for (cur.species.name in kSpeciesNames) {
         ## Initiate legend components.
         legend.legend <- vector(mode = "expression")
         legend.col <- vector(mode = "character")
         legend.pch <- vector(mode = "numeric")
         legend.lty <- vector(mode = "character")
         ## Get capitalized name for current species.
         cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
         ## Get data frame for current species, restricted to only the dependent and predictor variables, omitting NAs.
         cur.data.frame <- na.omit(object = subset(x = get(x = paste0("bart.", cur.species.name, ".clean.1.8")),
					 select = c(kDependentVariableRName,
						  kStandAgeVariableRName,
						  kProductivityIndexVariableRName)))
         ## Fit model.
         cur.model <- gam(formula = cur.formula,
		      data = cur.data.frame,
		      family = Gamma(link = "log"),
		      na.action = na.omit)
         ## Extract edf of smooth term.
         edf.smooth.term <- round(x = pen.edf(x = cur.model)[grepl(x = names(x = pen.edf(x = cur.model)), pattern = kPredictorVariableRName)], digits = 2)
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Plot term effect.
         plot.gam(x = cur.model,
	        rug = FALSE,
	        all.terms = TRUE,
	        select = kTermNumber,
	        main = cur.species.name.capitalized,
	        pages = 0,
	        shade = FALSE,
	        shade.col = kConfidenceBandShadeCol,
	        mgp = kPlotMgp,
	        xlim = kXLim,
	        ylim = kYLim,
	        xaxs = "i",
	        yaxs = "i",
	        xlab = as.expression(x = bquote(expr = .(kPredictorVariableMathName)*" [m]")),
	        ylab = as.expression(x = bquote(expr = italic("s")*"("*.(kPredictorVariableMathName)*", "*.(edf.smooth.term)*")")),
	        panel.first = abline(v = seq(from = round(x = kXLim[1],
						digits = kGridDigitsV),
				       to = round(x = kXLim[2],
					        digits = kGridDigitsV),
				       by = kGridIntervalV),
			         h  = seq(from = round(x = kYLim[1],
						 digits = kGridDigitsH),
				        to = round(x = kYLim[2],
					         digits = kGridDigitsV),
				        by = kGridIntervalH),
			         lty = kGridLineType,
			         lwd = kGridLineWidth,
			         col = kGridLineCol))
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        expression(""%+-%" standard error"),
		        "estimated effect")
         legend.col <- c(legend.col,
		     "black")
         legend.lty <- c(legend.lty,
		     "dashed",
		     "solid")
         ## Add rug.
         rug(x = cur.data.frame[[kPredictorVariableRName]],
	   ticksize = kRugTicksize,
	   side = 1,
	   lwd = kRugLwd,
	   col = kRugCol,
	   line = kRugLine)
         ## Draw box around plot.
         box(bty = "o")
         ## Add legend.
         legend(x = kLegendX,
	      legend = legend.legend,
	      lty = legend.lty,
	      col = legend.col,
	      bg = kLegendBg)
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.
     rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
** GAM1QQPlot.pdf
   #+NAME: GAM1QQPlot.pdf
   #+BEGIN_SRC R :results silent :var input=GAM1Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/GAM1Results.tex
     ## Preamble.
     kQQRep <- 10 ^ 4  ## 10 ^ 4 seems to be the minimum number of repetitions required to obtain stable estimates.
     ## Plotting preamble.
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kLegendX <- "topleft"
     kQQPCol <- "black"
     kQQLCol <- "black"
     kQQReCol <- "gray"
     kXLim <- list("beech" = c(-12.5, 15),
	         "spruce" = c(-20, 25))
     kYLim <- list("beech" = c(-17.5, 22.5),
	         "spruce" = c(-25, 35))
     kXLab <- "Theoretical quantiles"
     kYLab <- "Response residuals"
     ## Create "my.qq.gam", a custom version of "mgcv::qq.gam" which allows the customization of various graphics parameters.
     my.qq.gam.string <- deparse(expr = mgcv::qq.gam)
     my.qq.gam.string[1] <- paste0("my.qq.gam <- ", my.qq.gam.string[1])
     my.qq.gam.string <- paste0(my.qq.gam.string, collapse = "\n")
     my.qq.gam.string <- gsub(pattern = "function (object, rep = 0, level = 0.9, s.rep = 10, type = c(\"deviance\", \n    \"pearson\", \"response\"), pch = \".\", rl.col = 2, rep.col = \"gray80\", \n    ...)",
			fixed = TRUE,
			replacement = "function (object, rep = 0, level = 0.9, s.rep = 10, type = c(\"deviance\", \n    \"pearson\", \"response\"), rl.col = 2, rep.col = \"gray80\", \n xlab = \"theoretical quantiles\", ylab = NULL, pch = 19, ylim = NULL,   ...)",
			x = my.qq.gam.string)
     my.qq.gam.string <- gsub(pattern = "qqplot(Dq, D, ylab = ylab, xlab = \"theoretical quantiles\",",
			fixed = TRUE,
			replacement = "qqplot(Dq, D, ylab = ylab, xlab = xlab,",
			x = my.qq.gam.string)
     my.qq.gam.string <- gsub(pattern = "type <- match.arg(type)\n    ylab <- paste(type, \"residuals\")",
			fixed = TRUE,
			replacement = "if (is.null(ylab)) { \n    type <- match.arg(type)\n    ylab <- paste(type, \"residuals\")\n    }",
			x = my.qq.gam.string)
     my.qq.gam.string <- gsub(pattern = "    if (!is.null(Dq)) {\n        qqplot(Dq, D, ylab = ylab, xlab = xlab, \n            ylim = range(c(lim, D)), pch = pch, ...)",
			fixed = TRUE,
			replacement = "if (is.null(ylim)) {\n    ylim <- range(c(lim, D)) \n    } \n    if (!is.null(Dq)) {\n        qqplot(Dq, D, ylab = ylab, xlab = xlab, \n            ylim = ylim, pch = pch, ...)",
			x = my.qq.gam.string)
     eval(expr = parse(text = my.qq.gam.string))
     ## Create filename.
     file.name <- paste0(kGraphicsSubsubdir,
		     paste0(kModelID, "QQPlot.pdf"))
     ## Turn off graphics device.
     graphics.off()
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = file.name,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.90,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over all species names.
     for (cur.species.name in kSpeciesNames) {
         ## Initiate legend components.
         legend.legend <- vector(mode = "expression")
         legend.col <- vector(mode = "character")
         legend.pch <- vector(mode = "numeric")
         legend.lty <- vector(mode = "character")
         legend.lwd <- vector(mode = "numeric")
         ## Get capitalized name for current species.
         cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
         ## Get data frame for current species, restricted to only the dependent and predictor variables, omitting NAs.
         cur.data.frame <- na.omit(object = subset(x = get(x = paste0("bart.", cur.species.name, ".clean.1.8")),
					 select = c(kDependentVariableRName,
						  kStandAgeVariableRName,
						  kProductivityIndexVariableRName)))
         ## Fit model.
         cur.model <- gam(formula = cur.formula,
		      data = cur.data.frame,
		      family = Gamma(link = "log"),
		      na.action = na.omit)
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Create Q-Q plot.
         my.qq.gam(object = cur.model,
	         rep = kQQRep,
	         level = 0.90,
	         type = "response",
	         pch = kPointCharacter,
	         mgp = kPlotMgp,
	         xlim = kXLim[[cur.species.name]],
	         ylim = kYLim[[cur.species.name]],
	         main = cur.species.name.capitalized,
	         xaxs = "i",
	         yaxs = "i",
	         xlab = kXLab,
	         ylab = kYLab,
	         rep.col = kQQReCol,
	         rl.col = kQQLCol,
	         col = kQQPCol)
         ## Draw box around plot.
         box(bty = "o")
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        "1:1 reference line",
		        "residuals")
         legend.col <- c(legend.col,
		     kQQLCol,
		     kQQPCol)
         legend.pch <- c(legend.pch,
		     NA,
		     kPointCharacter)
         legend.lty <- c(legend.lty,
		     "solid",
		     NA)
         legend.lwd <- c(legend.lwd,
		     1,
		     NA)
         ## Add legend.
         legend(x = kLegendX,
	      legend = legend.legend,
	      col = legend.col,
	      pch = legend.pch,
	      lty = legend.lty,
	      lwd = legend.lwd,
	      bg = kLegendBg)
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.
     rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
** GAM1LinearPredictorResiduals.pdf
   #+NAME: GAM1LinearPredictorResiduals.pdf
   #+BEGIN_SRC R :results silent :var input=GAM1Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/GAM1Results.tex
     ## Plotting preamble.
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kLegendX <- "topleft"
     kXLab <- "Linear predictor"
     kYLab <- "Response residuals"
     kXLim <- list("beech" = c(2.5, 4),
	         "spruce" = c(2, 4.5))
     kYLim <- list("beech" = c(-15, 15),
	         "spruce" = c(-25, 25))
     kGridIntervalH <- list("beech" = 5,
		        "spruce" = 10)
     ## Create filename.
     file.name <- paste0(kGraphicsSubsubdir,
		     paste0(kModelID, "LinearPredictorResiduals.pdf"))
     ## Turn off graphics device.
     graphics.off()
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = file.name,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.90,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over all species names.
     for (cur.species.name in kSpeciesNames) {
         ## Initiate legend components.
         legend.legend <- vector(mode = "expression")
         legend.col <- vector(mode = "character")
         legend.pch <- vector(mode = "numeric")
         legend.lty <- vector(mode = "character")
         legend.lwd <- vector(mode = "numeric")
         ## Get capitalized name for current species.
         cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
         ## Get data frame for current species, restricted to only the dependent and predictor variables, omitting NAs.
         cur.data.frame <- na.omit(object = subset(x = get(x = paste0("bart.", cur.species.name, ".clean.1.8")),
					 select = c(kDependentVariableRName,
						  kStandAgeVariableRName,
						  kProductivityIndexVariableRName)))
         ## Fit model.
         cur.model <- gam(formula = cur.formula,
		      data = cur.data.frame,
		      family = Gamma(link = "log"),
		      na.action = na.omit)
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Extract linear predictors from model (cp. function "mgcv::gam.check").
         if (is.matrix(x = cur.model$linear.predictors) && !is.matrix(resid)) {
	   linpred <- napredict(cur.model$na.action, cur.model$linear.predictors[, 1])
         } else {
	   linpred <- napredict(cur.model$na.action, cur.model$linear.predictors)
         }
         ## Extract residuals from model (cp. function "mgcv::gam.check").
         resid <- residuals(object = cur.model,
		        type = "response")
         ## Create plot.
         plot(x = linpred,
	    y = resid,
	    pch = kPointCharacter,
	    main = cur.species.name.capitalized,
	    xlab = kXLab, 
	    ylab = kYLab,
	    xlim = kXLim[[cur.species.name]],
	    ylim = kYLim[[cur.species.name]],
	    xaxs = "i",
	    yaxs = "i",
	    mgp = kPlotMgp,
	    panel.first = abline(h  = seq(from = round(x = kYLim[[cur.species.name]][1],
					       digits = -1),
				    to = round(x = kYLim[[cur.species.name]][2],
					     digits = -1),
				    by = kGridIntervalH[[cur.species.name]]),
			     lty = kGridLineType,
			     lwd = kGridLineWidth,
			     col = kGridLineCol))
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.
     rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
** GAM1StandAgeBasalAreaObservationsPredictionsYieldClassClassification.pdf
   #+NAME: GAM1StandAgeBasalAreaObservationsPredictionsYieldClassClassification.pdf
   #+BEGIN_SRC R :results silent :var input=GAM1Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/GAM1Results.tex
     ## Plotting preamble ##
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kLegendNcol <- 2
     kXLim <- c(0, 160)
     kYLim <- c(0, 85)
     kGridIntervalV <- 10
     kGridIntervalH <- 10
     kLegendX <- list("beech" = "topleft",
		  "spruce" = "bottomright")
     kXValuesColumnNameTrainingData <- "alt"
     kXValuesColumnNameTestData <- "age"
     kYValuesColumnNameTrainingData <- "gha"
     kYValuesColumnNameTestData <- "gha.predictions"
     kXLab <- "Stand age [a]"
     kYLab <- expression(italic("G")*" ["*m^2*" ha"^-1*"]")
     ## Create file name.
     kFilename <-paste0(kGraphicsSubsubdir,
		    paste0(kModelID, "StandAgeBasalAreaObservationsPredictionsYieldClassClassification.pdf"))
     ## Define color palette generating function.
     kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
     ## Set best yield class level for which to interpolate SI.h100 values.
     kBestYieldClassLevel <- -2
     ## Turn off graphics device.
     graphics.off()
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = kFilename,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.85,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over species names.
     for (cur.species.name in kSpeciesNames) {
         ## Get capitalized name for current species.
         cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
         ## Fit model ##
         ## Get input data frame for current species.
         cur.input.data <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
         ## Subset input data frame to the variables mentioned in the model formula.
         cur.input.data.col.subset <- cur.input.data[, all.vars(expr = cur.formula)]
         ## Remove missing values from "cur.input.data.col.subset".
         cur.input.data.col.subset.na.omitted <- na.omit(object = cur.input.data.col.subset)
         ## Fit model.
         cur.model <- gam(formula = cur.formula,
		      family = kDistFamily,
		      data = cur.input.data.col.subset.na.omitted)
         ## Generate test data ##
         ## The test data should cover the same yield class range as the training data.
         ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
         SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
					"SI.h100" = NA)
         ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
         if (cur.species.name == "beech") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
         }
         if (cur.species.name == "spruce") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
         }
         ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
         for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	   SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	   SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
         }
         ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
         SI.h100.min <- min(cur.input.data[["SI.h100"]],
		        na.rm = TRUE)
         SI.h100.max <- max(cur.input.data[["SI.h100"]],
		        na.rm = TRUE)
         index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
         index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
         ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
         SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				   to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				   by = 0.1),
			     digits = 1)
         ## Initiate data frame in which to store test data.  The data frame will contain the following columns:
         ## - age
         ## - yield.class
         ## - h100
         ## - h100.EKL.I
         ## - SI.h100
         ## - SI.h100.diff.EKL.I
         test.df <- data.frame(NULL)
         ## Create age vector (required by all yield classes, so we make this assignment before starting the loop).
         age.vec <- seq(from = 0,
		    to = 160,
		    by = 1)
         ## Get SI.h100 value for yield class 1 (required by all yield classes, so we make this assignment before starting the loop).
         SI.h100.yield.class.1 <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == 1, "SI.h100"]
         ## Calculate h100 for yield class 1 using Nagel (1999), eq. (13) (required by all yield classes, so we make this assignment before starting the loop).
         h100.EKL.I.vec <- SI.h100.yield.class.1 * (beta3[[cur.species.name]] + beta4[[cur.species.name]] * log(x = age.vec)) + beta0[[cur.species.name]] + beta1[[cur.species.name]] * log(x = age.vec) + beta2[[cur.species.name]] * (log(x = age.vec)) ^ 2
         ## Loop over all yield classes required to cover the training data (i.e., the range from worst to best yield class needed).
         for (cur.yield.class in SI.h100.yield.class.values[index.worst.yield.class.needed:index.best.yield.class.needed, "yield.class"]) {
	   ## Get SI.h100 value for current yield class from "SI.h100.yield.class.values"
	   SI.h100.cur.yield.class <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == cur.yield.class, "SI.h100"]
	   ## Calculate h100 for the current yield class using Nagel (1999), eq. (13).
	   h100.vec <- SI.h100.cur.yield.class * (beta3[[cur.species.name]] + beta4[[cur.species.name]] * log(x = age.vec)) + beta0[[cur.species.name]] + beta1[[cur.species.name]] * log(x = age.vec) + beta2[[cur.species.name]] * (log(x = age.vec)) ^ 2
	   ## Calculate SI.h100 for the current yield class using Nagel (1999), eq. (13). [This procedure is a bit redundant, since it simply results in the "SI.h100.cur.yield.class" value defined above. I nevertheless opt for it, in order to make sure that the test data for sensitivity analysis is created in exactly the same way as the original data for model fitting was (cp. block "Create "gmax_merged_1.5.RData"").]
	   SI.h100.vec <- (h100.vec - beta0[[cur.species.name]] - beta1[[cur.species.name]] * log(x = age.vec) - beta2[[cur.species.name]] * ((log(x = age.vec)) ^ 2)) / (beta3[[cur.species.name]] + beta4[[cur.species.name]] * log(x = age.vec))
	   ## Calculate difference between SI.h100 value of current yield class and SI.h100 value of yield class 1.
	   SI.h100.diff.EKL.I.vec <- round(x = SI.h100.vec - SI.h100.yield.class.1, digits = 1)
	   ## Append the vectors for the current yield class to "test.df". 
	   test.df <- rbind(test.df,
			data.frame("age" = age.vec,
				 "yield.class" = as.factor(x = cur.yield.class),
				 "h100" = h100.vec,
				 "h100.EKL.I" = h100.EKL.I.vec,
				 "SI.h100" = SI.h100.vec,
				 "SI.h100.diff.EKL.I" = SI.h100.diff.EKL.I.vec))
         }
         ## Plot observations ##
         ## Initiate legend components.
         legend.legend <- vector(mode = "character")
         legend.pch <- vector(mode = "numeric")
         legend.lty <- vector(mode = "character")
         legend.lwd <- vector(mode = "numeric")
         legend.col <- vector(mode = "character")
         ## Generate a color palette of the same length as "SI.h100.sequence".
         cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Create empty plot.
         plot(x = cur.input.data[[kXValuesColumnNameTrainingData]],
	    type = "n",
	    xlim = kXLim,
	    ylim = kYLim,
	    xlab = kXLab,
	    ylab = kYLab,
	    main = cur.species.name.capitalized,
	    mgp = kPlotMgp,
	    xaxs = "i",
	    yaxs = "i",
	    panel.first = abline(v = seq(from = kXLim[1],
				   to = kXLim[2],
				   by = kGridIntervalV),
			     h  = seq(from = kYLim[1],
				    to = kYLim[2],
				    by = kGridIntervalH),
			     lty = kGridLineType,
			     lwd = kGridLineWidth,
			     col = kGridLineCol))
         ## Loop over all evdids.
         for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	   ## Create subset of "cur.input.data", based on current edvid.
	   edvid.subset <- subset(x = cur.input.data,
			      subset = edvid == cur.edvid)
	   ## Add lines for observations belonging to current edvid.
	   lines(x =edvid.subset[[kXValuesColumnNameTrainingData]],
	         y = edvid.subset[[kYValuesColumnNameTrainingData]],
	         lwd = kLineWidth,
	         lty = kLineType)
         }
         ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
         for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	   ## Create subset of "cur.input.data", based on current edvid.
	   edvid.subset <- subset(x = cur.input.data,
			      subset = edvid == cur.edvid)
	   ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	   SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
					table = SI.h100.sequence)
	   ## Add points to plot.
	   points(x = edvid.subset[[kXValuesColumnNameTrainingData]],
		y = edvid.subset[[kYValuesColumnNameTrainingData]],
		col = cur.species.color.palette[SI.h100.rounded.color.index],
		pch = kPointCharacter)
         }
         ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
         SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						       digits = 1),
					       table = SI.h100.sequence)
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        paste0("observations yield class ",
			     SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
         legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
         legend.pch <- c(legend.pch, rep(x = kPointCharacter, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
         legend.lty <- c(legend.lty, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
         legend.lwd <- c(legend.lwd, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
         ## Add model predictions to plot ##
         ## Get test data for current species.
         new.data <- test.df
         ## Restrict "new.data" to the columns of the independent variables of the current model.
         new.data <- subset(x = new.data,
		        select = all.vars(cur.formula)[-1])
         ## Calculate model predictions.
         new.data[[kYValuesColumnNameTestData]] <- predict(object = cur.model,
					         newdata = new.data,
					         what = "mu",
					         type = "response")
         ## Reattach columns "age", "h100", and "yield.class" to "new.data".
         new.data[["age"]] <- test.df[["age"]]
         new.data[["h100"]] <- test.df[["h100"]]
         new.data[["yield.class"]] <- test.df[["yield.class"]]
         ## Add lines to plot per yield class.
         all.cols <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
         for (cur.yield.class.index in seq_len(length.out = length(x = levels(x = new.data[["yield.class"]])))) {
	   yield.class.name <- levels(x = new.data[["yield.class"]])[cur.yield.class.index]
	   line.col <- all.cols[cur.yield.class.index]
	   lines(x = new.data[[kXValuesColumnNameTestData]][new.data[["yield.class"]] == yield.class.name],
	         y = new.data[[kYValuesColumnNameTestData]][new.data[["yield.class"]] == yield.class.name],
	         col = line.col,
	         lty = kLineType,
	         lwd = kLineWidth)
         }
         ## Add box around plot.
         box(bty = "o")
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        paste0("predictions yield class ",
			     SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
         legend.col <- c(legend.col,
		     cur.species.color.palette[SI.h100.yield.class.values.color.index])
         legend.pch <- c(legend.pch,
		     rep(x = NA,
		         times = length(x = SI.h100.yield.class.values[["yield.class"]])))
         legend.lty <- c(legend.lty,
		     rep(x = kLineType,
		         times = length(x = SI.h100.yield.class.values[["yield.class"]])))
         legend.lwd <- c(legend.lwd,
		     rep(x = kLineWidth,
		         times = length(x = SI.h100.yield.class.values[["yield.class"]])))
         ## Add legend.
         legend(x = kLegendX[[cur.species.name]],
	      ncol = kLegendNcol,
	      legend = legend.legend,
	      col = legend.col,
	      pch = legend.pch,
	      lty = legend.lty,
	      lwd = legend.lwd,
	      bg = kLegendBg)
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.                                   
     rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
** GAM1TopHeightBasalAreaObservationsPredictionsYieldClassClassification.pdf
   #+NAME: GAM1TopHeightBasalAreaObservationsPredictionsYieldClassClassification.pdf
   #+BEGIN_SRC R :results silent :var input=GAM1Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/GAM1Results.tex
     ## Plotting preamble ##
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kLegendNcol <- 2
     kXLim <- c(0, 55)
     kYLim <- c(0, 85)
     kGridIntervalV <- 5
     kGridIntervalH <- 10
     kLegendX <- list("beech" = "topleft",
		  "spruce" = "bottomright")
     kXValuesColumnNameTrainingData <- "h100"
     kXValuesColumnNameTestData <- "h100"
     kYValuesColumnNameTrainingData <- "gha"
     kYValuesColumnNameTestData <- "gha.predictions"
     kXLab <- expression(italic("h")["100"]*" [m]")
     kYLab <- expression(italic("G")*" ["*m^2*" ha"^-1*"]")
     ## Create file name.
     kFilename <-paste0(kGraphicsSubsubdir,
		    paste0(kModelID, "TopHeightBasalAreaObservationsPredictionsYieldClassClassification.pdf"))
     ## Define color palette generating function.
     kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
     ## Set best yield class level for which to interpolate SI.h100 values.
     kBestYieldClassLevel <- -2
     ## Turn off graphics device.
     graphics.off()
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = kFilename,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.85,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over species names.
     for (cur.species.name in kSpeciesNames) {
         ## Get capitalized name for current species.
         cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
         ## Fit model ##
         ## Get input data frame for current species.
         cur.input.data <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
         ## Subset input data frame to the variables mentioned in the model formula.
         cur.input.data.col.subset <- cur.input.data[, all.vars(expr = cur.formula)]
         ## Remove missing values from "cur.input.data.col.subset".
         cur.input.data.col.subset.na.omitted <- na.omit(object = cur.input.data.col.subset)
         ## Fit model.
         cur.model <- gam(formula = cur.formula,
		      family = kDistFamily,
		      data = cur.input.data.col.subset.na.omitted)
         ## Generate test data ##
         ## The test data should cover the same yield class range as the training data.
         ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
         SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
					"SI.h100" = NA)
         ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
         if (cur.species.name == "beech") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
         }
         if (cur.species.name == "spruce") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
         }
         ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
         for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	   SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	   SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
         }
         ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
         SI.h100.min <- min(cur.input.data[["SI.h100"]],
		        na.rm = TRUE)
         SI.h100.max <- max(cur.input.data[["SI.h100"]],
		        na.rm = TRUE)
         index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
         index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
         ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
         SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				   to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				   by = 0.1),
			     digits = 1)
         ## Initiate data frame in which to store test data.  The data frame will contain the following columns:
         ## - age
         ## - yield.class
         ## - h100
         ## - h100.EKL.I
         ## - SI.h100
         ## - SI.h100.diff.EKL.I
         test.df <- data.frame(NULL)
         ## Create age vector (required by all yield classes, so we make this assignment before starting the loop).
         age.vec <- seq(from = 0,
		    to = 160,
		    by = 1)
         ## Get SI.h100 value for yield class 1 (required by all yield classes, so we make this assignment before starting the loop).
         SI.h100.yield.class.1 <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == 1, "SI.h100"]
         ## Calculate h100 for yield class 1 using Nagel (1999), eq. (13) (required by all yield classes, so we make this assignment before starting the loop).
         h100.EKL.I.vec <- SI.h100.yield.class.1 * (beta3[[cur.species.name]] + beta4[[cur.species.name]] * log(x = age.vec)) + beta0[[cur.species.name]] + beta1[[cur.species.name]] * log(x = age.vec) + beta2[[cur.species.name]] * (log(x = age.vec)) ^ 2
         ## Loop over all yield classes required to cover the training data (i.e., the range from worst to best yield class needed).
         for (cur.yield.class in SI.h100.yield.class.values[index.worst.yield.class.needed:index.best.yield.class.needed, "yield.class"]) {
	   ## Get SI.h100 value for current yield class from "SI.h100.yield.class.values"
	   SI.h100.cur.yield.class <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == cur.yield.class, "SI.h100"]
	   ## Calculate h100 for the current yield class using Nagel (1999), eq. (13).
	   h100.vec <- SI.h100.cur.yield.class * (beta3[[cur.species.name]] + beta4[[cur.species.name]] * log(x = age.vec)) + beta0[[cur.species.name]] + beta1[[cur.species.name]] * log(x = age.vec) + beta2[[cur.species.name]] * (log(x = age.vec)) ^ 2
	   ## Calculate SI.h100 for the current yield class using Nagel (1999), eq. (13). [This procedure is a bit redundant, since it simply results in the "SI.h100.cur.yield.class" value defined above. I nevertheless opt for it, in order to make sure that the test data for sensitivity analysis is created in exactly the same way as the original data for model fitting was (cp. block "Create "gmax_merged_1.5.RData"").]
	   SI.h100.vec <- (h100.vec - beta0[[cur.species.name]] - beta1[[cur.species.name]] * log(x = age.vec) - beta2[[cur.species.name]] * ((log(x = age.vec)) ^ 2)) / (beta3[[cur.species.name]] + beta4[[cur.species.name]] * log(x = age.vec))
	   ## Calculate difference between SI.h100 value of current yield class and SI.h100 value of yield class 1.
	   SI.h100.diff.EKL.I.vec <- round(x = SI.h100.vec - SI.h100.yield.class.1, digits = 1)
	   ## Append the vectors for the current yield class to "test.df". 
	   test.df <- rbind(test.df,
			data.frame("age" = age.vec,
				 "yield.class" = as.factor(x = cur.yield.class),
				 "h100" = h100.vec,
				 "h100.EKL.I" = h100.EKL.I.vec,
				 "SI.h100" = SI.h100.vec,
				 "SI.h100.diff.EKL.I" = SI.h100.diff.EKL.I.vec))
         }
         ## Plot observations ##
         ## Initiate legend components.
         legend.legend <- vector(mode = "character")
         legend.pch <- vector(mode = "numeric")
         legend.lty <- vector(mode = "character")
         legend.lwd <- vector(mode = "numeric")
         legend.col <- vector(mode = "character")
         ## Generate a color palette of the same length as "SI.h100.sequence".
         cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Create empty plot.
         plot(x = cur.input.data[[kXValuesColumnNameTrainingData]],
	    type = "n",
	    xlim = kXLim,
	    ylim = kYLim,
	    xlab = kXLab,
	    ylab = kYLab,
	    main = cur.species.name.capitalized,
	    mgp = kPlotMgp,
	    xaxs = "i",
	    yaxs = "i",
	    panel.first = abline(v = seq(from = kXLim[1],
				   to = kXLim[2],
				   by = kGridIntervalV),
			     h  = seq(from = kYLim[1],
				    to = kYLim[2],
				    by = kGridIntervalH),
			     lty = kGridLineType,
			     lwd = kGridLineWidth,
			     col = kGridLineCol))
         ## Loop over all evdids.
         for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	   ## Create subset of "cur.input.data", based on current edvid.
	   edvid.subset <- subset(x = cur.input.data,
			      subset = edvid == cur.edvid)
	   ## Add lines for observations belonging to current edvid.
	   lines(x =edvid.subset[[kXValuesColumnNameTrainingData]],
	         y = edvid.subset[[kYValuesColumnNameTrainingData]],
	         lwd = kLineWidth,
	         lty = kLineType)
         }
         ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
         for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	   ## Create subset of "cur.input.data", based on current edvid.
	   edvid.subset <- subset(x = cur.input.data,
			      subset = edvid == cur.edvid)
	   ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	   SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
					table = SI.h100.sequence)
	   ## Add points to plot.
	   points(x = edvid.subset[[kXValuesColumnNameTrainingData]],
		y = edvid.subset[[kYValuesColumnNameTrainingData]],
		col = cur.species.color.palette[SI.h100.rounded.color.index],
		pch = kPointCharacter)
         }
         ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
         SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						       digits = 1),
					       table = SI.h100.sequence)
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        paste0("observations yield class ",
			     SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
         legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
         legend.pch <- c(legend.pch, rep(x = kPointCharacter, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
         legend.lty <- c(legend.lty, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
         legend.lwd <- c(legend.lwd, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
         ## Add model predictions to plot ##
         ## Get test data for current species.
         new.data <- test.df
         ## Restrict "new.data" to the columns of the independent variables of the current model.
         new.data <- subset(x = new.data,
		        select = all.vars(cur.formula)[-1])
         ## Calculate model predictions.
         new.data[[kYValuesColumnNameTestData]] <- predict(object = cur.model,
					         newdata = new.data,
					         what = "mu",
					         type = "response")
         ## Reattach columns "age", "h100", and "yield.class" to "new.data".
         new.data[["age"]] <- test.df[["age"]]
         new.data[["h100"]] <- test.df[["h100"]]
         new.data[["yield.class"]] <- test.df[["yield.class"]]
         ## Add lines to plot per yield class.
         all.cols <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
         for (cur.yield.class.index in seq_len(length.out = length(x = levels(x = new.data[["yield.class"]])))) {
	   yield.class.name <- levels(x = new.data[["yield.class"]])[cur.yield.class.index]
	   line.col <- all.cols[cur.yield.class.index]
	   lines(x = new.data[[kXValuesColumnNameTestData]][new.data[["yield.class"]] == yield.class.name],
	         y = new.data[[kYValuesColumnNameTestData]][new.data[["yield.class"]] == yield.class.name],
	         col = line.col,
	         lty = kLineType,
	         lwd = kLineWidth)
         }
         ## Add box around plot.
         box(bty = "o")
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        paste0("predictions yield class ",
			     SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
         legend.col <- c(legend.col,
		     cur.species.color.palette[SI.h100.yield.class.values.color.index])
         legend.pch <- c(legend.pch,
		     rep(x = NA,
		         times = length(x = SI.h100.yield.class.values[["yield.class"]])))
         legend.lty <- c(legend.lty,
		     rep(x = kLineType,
		         times = length(x = SI.h100.yield.class.values[["yield.class"]])))
         legend.lwd <- c(legend.lwd,
		     rep(x = kLineWidth,
		         times = length(x = SI.h100.yield.class.values[["yield.class"]])))
         ## Add legend.
         legend(x = kLegendX[[cur.species.name]],
	      ncol = kLegendNcol,
	      legend = legend.legend,
	      col = legend.col,
	      pch = legend.pch,
	      lty = legend.lty,
	      lwd = legend.lwd,
	      bg = kLegendBg)
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.                                   
     rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
* GAM2
** GAM2Preamble
   #+NAME: GAM2Preamble
   #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
     ## Modelling preamble ##
     library(package = "mgcv", character.only = TRUE)
     kModelID <- "GAM2"
     kDistFamily <- Gamma(link = "log")
     cur.formula <- kFormulas[[kModelID]]
     kGraphicsSubsubdir <- paste0(kGraphicsSubdir, kModelID, "/")
     objects.at.script.start <- c(objects.at.script.start,
			    "kModelID",
			    "kDistFamily",
			    "cur.formula",
			    "kGraphicsSubsubdir")
     system2(command = "mkdir",
	   args = paste0("-p ", kGraphicsSubsubdir))
   #+END_SRC
** GAM2EffectStandAgeVariable.pdf
   #+NAME: GAM2EffectStandAgeVariable.pdf
   #+BEGIN_SRC R :results silent :var input=GAM2Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/GAM2Results.tex
     ## Preamble.
     kPredictorVariableRName <- kStandAgeVariableRName
     kPredictorVariableMathName <- kStandAgeVariableMathName
     kTermNumber <- 1
     ## Plotting preamble.
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kXLim <- c(0, 40)
     kYLim <- c(-3, 1)
     kGridIntervalV <- 2.5
     kGridIntervalH <- 0.5
     kGridDigitsV <- 0
     kGridDigitsH <- 0
     kRugTicksize <- 0.05
     kRugLwd <- 0.5
     kRugCol <- "gray"
     kRugCol <- "black"
     kRugLine <- -0.5
     kConfidenceBandShadeCol <- "gray"
     kLegendX <- "topleft"
     ## Create filename.
     file.name <- paste0(kGraphicsSubsubdir,
		     paste0(kModelID, "EffectStandAgeVariable.pdf"))
     ## Turn off graphics device.
     graphics.off()
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = file.name,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.90,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over all species names.
     for (cur.species.name in kSpeciesNames) {
         ## Initiate legend components.
         legend.legend <- vector(mode = "expression")
         legend.col <- vector(mode = "character")
         legend.pch <- vector(mode = "numeric")
         legend.lty <- vector(mode = "character")
         ## Get capitalized name for current species.
         cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
         ## Get data frame for current species, restricted to only the dependent and predictor variables, omitting NAs.
         cur.data.frame <- na.omit(object = subset(x = get(x = paste0("bart.", cur.species.name, ".clean.1.8")),
					 select = c(kDependentVariableRName,
						  kStandAgeVariableRName,
						  kProductivityIndexVariableRName)))
         ## Fit model.
         cur.model <- gam(formula = cur.formula,
		      data = cur.data.frame,
		      family = Gamma(link = "log"),
		      na.action = na.omit)
         ## Extract edf of smooth term.
         edf.smooth.term <- round(x = pen.edf(x = cur.model)[grepl(x = names(x = pen.edf(x = cur.model)), pattern = kPredictorVariableRName)], digits = 2)
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Plot term effect.
         plot.gam(x = cur.model,
	        rug = FALSE,
	        all.terms = TRUE,
	        select = kTermNumber,
	        main = cur.species.name.capitalized,
	        pages = 0,
	        shade = FALSE,
	        shade.col = kConfidenceBandShadeCol,
	        mgp = kPlotMgp,
	        xlim = kXLim,
	        ylim = kYLim,
	        xaxs = "i",
	        yaxs = "i",
	        xlab = as.expression(x = bquote(expr = .(kPredictorVariableMathName)*" [m]")),
	        ylab = as.expression(x = bquote(expr = italic("s")*"("*.(kPredictorVariableMathName)*", "*.(edf.smooth.term)*")")),
	        panel.first = abline(v = seq(from = round(x = kXLim[1],
						digits = kGridDigitsV),
				       to = round(x = kXLim[2],
					        digits = kGridDigitsV),
				       by = kGridIntervalV),
			         h  = seq(from = round(x = kYLim[1],
						 digits = kGridDigitsH),
				        to = round(x = kYLim[2],
					         digits = kGridDigitsH),
				        by = kGridIntervalH),
			         lty = kGridLineType,
			         lwd = kGridLineWidth,
			         col = kGridLineCol))
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        expression(""%+-%" standard error"),
		        "estimated effect")
         legend.col <- c(legend.col,
		     "black")
         legend.lty <- c(legend.lty,
		     "dashed",
		     "solid")
         ## Add rug.
         rug(x = cur.data.frame[[kPredictorVariableRName]],
	   ticksize = kRugTicksize,
	   side = 1,
	   lwd = kRugLwd,
	   col = kRugCol,
	   line = kRugLine)
         ## Draw box around plot.
         box(bty = "o")
         ## Add legend.
         legend(x = kLegendX,
	      legend = legend.legend,
	      lty = legend.lty,
	      col = legend.col,
	      bg = kLegendBg)
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.
     rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
** GAM2EffectProductivityIndexVariable.pdf
   #+NAME: GAM2EffectProductivityIndexVariable.pdf
   #+BEGIN_SRC R :results silent :var input=GAM2Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/GAM2Results.tex
     ## Preamble.
     kPredictorVariableRName <- kProductivityIndexVariableRName
     kPredictorVariableMathName <- kProductivityIndexVariableMathName
     kTermNumber <- 2
     ## Plotting preamble.
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kXLim <- c(-12.5, 12.5)
     kYLim <- c(-0.4, 0.45)
     kGridIntervalV <- 1
     kGridIntervalH <- 0.1
     kGridDigitsV <- -1
     kGridDigitsH <- 1
     kRugTicksize <- 0.05
     kRugLwd <- 0.5
     kRugCol <- "gray"
     kRugCol <- "black"
     kRugLine <- -0.5
     kConfidenceBandShadeCol <- "gray"
     kLegendX <- "topleft"
     ## Create filename.
     file.name <- paste0(kGraphicsSubsubdir,
		     paste0(kModelID, "EffectProductivityIndexVariable.pdf"))
     ## Turn off graphics device.
     graphics.off()
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = file.name,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.90,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over all species names.
     for (cur.species.name in kSpeciesNames) {
         ## Initiate legend components.
         legend.legend <- vector(mode = "expression")
         legend.col <- vector(mode = "character")
         legend.pch <- vector(mode = "numeric")
         legend.lty <- vector(mode = "character")
         ## Get capitalized name for current species.
         cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
         ## Get data frame for current species, restricted to only the dependent and predictor variables, omitting NAs.
         cur.data.frame <- na.omit(object = subset(x = get(x = paste0("bart.", cur.species.name, ".clean.1.8")),
					 select = c(kDependentVariableRName,
						  kStandAgeVariableRName,
						  kProductivityIndexVariableRName)))
         ## Fit model.
         cur.model <- gam(formula = cur.formula,
		      data = cur.data.frame,
		      family = Gamma(link = "log"),
		      na.action = na.omit)
         ## Extract edf of smooth term.
         edf.smooth.term <- round(x = pen.edf(x = cur.model)[grepl(x = names(x = pen.edf(x = cur.model)), pattern = kPredictorVariableRName)], digits = 2)
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Plot term effect.
         termplot(model = cur.model,
	        se = TRUE,
	        rug = FALSE,
	        col.se = "black",
	        col.term = "black",
	        main = cur.species.name.capitalized,
	        mgp = kPlotMgp,
	        ylim = kYLim,
	        xaxs = "i",
	        yaxs = "i",
	        xlab = as.expression(x = bquote(expr = .(kPredictorVariableMathName)*" [m]")),
	        ylab = as.expression(x = bquote(expr = italic("s")*"("*.(kPredictorVariableMathName)*", "*.(edf.smooth.term)*")")),
	        panel.first = abline(v = seq(from = round(x = kXLim[1],
						digits = kGridDigitsV),
				       to = round(x = kXLim[2],
					        digits = kGridDigitsV),
				       by = kGridIntervalV),
			         h  = seq(from = round(x = kYLim[1],
						 digits = kGridDigitsH),
				        to = round(x = kYLim[2],
					         digits = kGridDigitsH),
				        by = kGridIntervalH),
			         lty = kGridLineType,
			         lwd = kGridLineWidth,
			         col = kGridLineCol))
         ## plot.gam(x = cur.model,
	        ## rug = FALSE,
	        ## all.terms = TRUE,
	        ## select = kTermNumber,
	        ## main = cur.species.name.capitalized,
	        ## pages = 0,
	        ## shade = FALSE,
	        ## shade.col = kConfidenceBandShadeCol,
	        ## mgp = kPlotMgp,
	        ## xlim = kXLim,
	        ## ylim = kYLim,
	        ## xaxs = "i",
	        ## yaxs = "i",
	        ## xlab = as.expression(x = bquote(expr = .(kPredictorVariableMathName)*" [m]")),
	        ## ylab = as.expression(x = bquote(expr = italic("s")*"("*.(kPredictorVariableMathName)*", "*.(edf.smooth.term)*")")),
	        ## panel.first = abline(v = seq(from = round(x = kXLim[1],
						## digits = -1),
				       ## to = round(x = kXLim[2],
					        ## digits = -1),
				       ## by = kGridIntervalV),
			         ## h  = seq(from = round(x = kYLim[1]),
				        ## to = round(x = kYLim[2]),
				        ## by = kGridIntervalH),
			         ## lty = kGridLineType,
			         ## lwd = kGridLineWidth,
			         ## col = kGridLineCol))
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        expression(""%+-%" standard error"),
		        "estimated effect")
         legend.col <- c(legend.col,
		     "black")
         legend.lty <- c(legend.lty,
		     "dashed",
		     "solid")
         ## Add rug.
         rug(x = cur.data.frame[[kPredictorVariableRName]],
	   ticksize = kRugTicksize,
	   side = 1,
	   lwd = kRugLwd,
	   col = kRugCol,
	   line = kRugLine)
         ## Draw box around plot.
         box(bty = "o")
         ## Add legend.
         legend(x = kLegendX,
	      legend = legend.legend,
	      lty = legend.lty,
	      col = legend.col,
	      bg = kLegendBg)
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.
     ## rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
** GAM2QQPlot.pdf
   #+NAME: GAM2QQPlot.pdf
   #+BEGIN_SRC R :results silent :var input=GAM2Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/GAM2Results.tex
     ## Preamble.
     kQQRep <- 10 ^ 4  ## 10 ^ 4 seems to be the minimum number of repetitions required to obtain stable estimates.
     ## Plotting preamble.
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kLegendX <- "topleft"
     kQQPCol <- "black"
     kQQLCol <- "black"
     kQQReCol <- "gray"
     kXLim <- list("beech" = c(-15, 19),
	         "spruce" = c(-21, 27))
     kYLim <- list("beech" = c(-20, 26),
	         "spruce" = c(-27, 37))
     kXLab <- "Theoretical quantiles"
     kYLab <- "Response residuals"
     ## Create "my.qq.gam", a custom version of "mgcv::qq.gam" which allows the customization of various graphics parameters.
     my.qq.gam.string <- deparse(expr = mgcv::qq.gam)
     my.qq.gam.string[1] <- paste0("my.qq.gam <- ", my.qq.gam.string[1])
     my.qq.gam.string <- paste0(my.qq.gam.string, collapse = "\n")
     my.qq.gam.string <- gsub(pattern = "function (object, rep = 0, level = 0.9, s.rep = 10, type = c(\"deviance\", \n    \"pearson\", \"response\"), pch = \".\", rl.col = 2, rep.col = \"gray80\", \n    ...)",
			fixed = TRUE,
			replacement = "function (object, rep = 0, level = 0.9, s.rep = 10, type = c(\"deviance\", \n    \"pearson\", \"response\"), rl.col = 2, rep.col = \"gray80\", \n xlab = \"theoretical quantiles\", ylab = NULL, pch = 19, ylim = NULL,   ...)",
			x = my.qq.gam.string)
     my.qq.gam.string <- gsub(pattern = "qqplot(Dq, D, ylab = ylab, xlab = \"theoretical quantiles\",",
			fixed = TRUE,
			replacement = "qqplot(Dq, D, ylab = ylab, xlab = xlab,",
			x = my.qq.gam.string)
     my.qq.gam.string <- gsub(pattern = "type <- match.arg(type)\n    ylab <- paste(type, \"residuals\")",
			fixed = TRUE,
			replacement = "if (is.null(ylab)) { \n    type <- match.arg(type)\n    ylab <- paste(type, \"residuals\")\n    }",
			x = my.qq.gam.string)
     my.qq.gam.string <- gsub(pattern = "    if (!is.null(Dq)) {\n        qqplot(Dq, D, ylab = ylab, xlab = xlab, \n            ylim = range(c(lim, D)), pch = pch, ...)",
			fixed = TRUE,
			replacement = "if (is.null(ylim)) {\n    ylim <- range(c(lim, D)) \n    } \n    if (!is.null(Dq)) {\n        qqplot(Dq, D, ylab = ylab, xlab = xlab, \n            ylim = ylim, pch = pch, ...)",
			x = my.qq.gam.string)
     eval(expr = parse(text = my.qq.gam.string))
     ## Create filename.
     file.name <- paste0(kGraphicsSubsubdir,
		     paste0(kModelID, "QQPlot.pdf"))
     ## Turn off graphics device.
     graphics.off()
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = file.name,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.90,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over all species names.
     for (cur.species.name in kSpeciesNames) {
         ## Initiate legend components.
         legend.legend <- vector(mode = "expression")
         legend.col <- vector(mode = "character")
         legend.pch <- vector(mode = "numeric")
         legend.lty <- vector(mode = "character")
         legend.lwd <- vector(mode = "numeric")
         ## Get capitalized name for current species.
         cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
         ## Get data frame for current species, restricted to only the dependent and predictor variables, omitting NAs.
         cur.data.frame <- na.omit(object = subset(x = get(x = paste0("bart.", cur.species.name, ".clean.1.8")),
					 select = c(kDependentVariableRName,
						  kStandAgeVariableRName,
						  kProductivityIndexVariableRName)))
         ## Fit model.
         cur.model <- gam(formula = cur.formula,
		      data = cur.data.frame,
		      family = Gamma(link = "log"),
		      na.action = na.omit)
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Create Q-Q plot.
         my.qq.gam(object = cur.model,
	         rep = kQQRep,
	         level = 0.90,
	         type = "response",
	         pch = kPointCharacter,
	         mgp = kPlotMgp,
	         xlim = kXLim[[cur.species.name]],
	         ylim = kYLim[[cur.species.name]],
	         main = cur.species.name.capitalized,
	         xaxs = "i",
	         yaxs = "i",
	         xlab = kXLab,
	         ylab = kYLab,
	         rep.col = kQQReCol,
	         rl.col = kQQLCol,
	         col = kQQPCol)
         ## Draw box around plot.
         box(bty = "o")
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        "1:1 reference line",
		        "residuals")
         legend.col <- c(legend.col,
		     kQQLCol,
		     kQQPCol)
         legend.pch <- c(legend.pch,
		     NA,
		     kPointCharacter)
         legend.lty <- c(legend.lty,
		     "solid",
		     NA)
         legend.lwd <- c(legend.lwd,
		     1,
		     NA)
         ## Add legend.
         legend(x = kLegendX,
	      legend = legend.legend,
	      col = legend.col,
	      pch = legend.pch,
	      lty = legend.lty,
	      lwd = legend.lwd,
	      bg = kLegendBg)
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.
     rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
** GAM2LinearPredictorResiduals.pdf
   #+NAME: GAM2LinearPredictorResiduals.pdf
   #+BEGIN_SRC R :results silent :var input=GAM2Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/GAM2Results.tex
     ## Plotting preamble.
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kLegendX <- "topleft"
     kXLab <- "Linear predictor"
     kYLab <- "Response residuals"
     kXLim <- list("beech" = c(3.1, 3.9),
	         "spruce" = c(2.25, 4.25))
     kYLim <- list("beech" = c(-17, 17),
	         "spruce" = c(-30, 30))
     kGridIntervalH <- list("beech" = 5,
		        "spruce" = 10)
     ## Create filename.
     file.name <- paste0(kGraphicsSubsubdir,
		     paste0(kModelID, "LinearPredictorResiduals.pdf"))
     ## Turn off graphics device.
     graphics.off()
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = file.name,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.90,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over all species names.
     for (cur.species.name in kSpeciesNames) {
         ## Initiate legend components.
         legend.legend <- vector(mode = "expression")
         legend.col <- vector(mode = "character")
         legend.pch <- vector(mode = "numeric")
         legend.lty <- vector(mode = "character")
         legend.lwd <- vector(mode = "numeric")
         ## Get capitalized name for current species.
         cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
         ## Get data frame for current species, restricted to only the dependent and predictor variables, omitting NAs.
         cur.data.frame <- na.omit(object = subset(x = get(x = paste0("bart.", cur.species.name, ".clean.1.8")),
					 select = c(kDependentVariableRName,
						  kStandAgeVariableRName,
						  kProductivityIndexVariableRName)))
         ## Fit model.
         cur.model <- gam(formula = cur.formula,
		      data = cur.data.frame,
		      family = Gamma(link = "log"),
		      na.action = na.omit)
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Extract linear predictors from model (cp. function "mgcv::gam.check").
         if (is.matrix(x = cur.model$linear.predictors) && !is.matrix(resid)) {
	   linpred <- napredict(cur.model$na.action, cur.model$linear.predictors[, 1])
         } else {
	   linpred <- napredict(cur.model$na.action, cur.model$linear.predictors)
         }
         ## Extract residuals from model (cp. function "mgcv::gam.check").
         resid <- residuals(object = cur.model,
		        type = "response")
         ## Create plot.
         plot(x = linpred,
	    y = resid,
	    pch = kPointCharacter,
	    main = cur.species.name.capitalized,
	    xlab = kXLab, 
	    ylab = kYLab,
	    xlim = kXLim[[cur.species.name]],
	    ylim = kYLim[[cur.species.name]],
	    xaxs = "i",
	    yaxs = "i",
	    mgp = kPlotMgp,
	    panel.first = abline(h  = seq(from = round(x = kYLim[[cur.species.name]][1],
					       digits = -1),
				    to = round(x = kYLim[[cur.species.name]][2],
					     digits = -1),
				    by = kGridIntervalH[[cur.species.name]]),
			     lty = kGridLineType,
			     lwd = kGridLineWidth,
			     col = kGridLineCol))
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.
     rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
** GAM2StandAgeBasalAreaObservationsPredictionsYieldClassClassification.pdf
   #+NAME: GAM2StandAgeBasalAreaObservationsPredictionsYieldClassClassification.pdf
   #+BEGIN_SRC R :results silent :var input=GAM2Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/GAM2Results.tex
     ## Plotting preamble ##
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kLegendNcol <- 2
     kXLim <- c(0, 160)
     kYLim <- c(0, 90)
     kGridIntervalV <- 10
     kGridIntervalH <- 10
     kLegendX <- list("beech" = "topleft",
		  "spruce" = "bottomright")
     kXValuesColumnNameTrainingData <- "alt"
     kXValuesColumnNameTestData <- "age"
     kYValuesColumnNameTrainingData <- "gha"
     kYValuesColumnNameTestData <- "gha.predictions"
     kXLab <- "Stand age [a]"
     kYLab <- expression(italic("G")*" ["*m^2*" ha"^-1*"]")
     ## Create file name.
     kFilename <-paste0(kGraphicsSubsubdir,
		    paste0(kModelID, "StandAgeBasalAreaObservationsPredictionsYieldClassClassification.pdf"))
     ## Define color palette generating function.
     kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
     ## Set best yield class level for which to interpolate SI.h100 values.
     kBestYieldClassLevel <- -2
     ## Turn off graphics device.
     graphics.off()
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = kFilename,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.85,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over species names.
     for (cur.species.name in kSpeciesNames) {
         ## Get capitalized name for current species.
         cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
         ## Fit model ##
         ## Get input data frame for current species.
         cur.input.data <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
         ## Subset input data frame to the variables mentioned in the model formula.
         cur.input.data.col.subset <- cur.input.data[, all.vars(expr = cur.formula)]
         ## Remove missing values from "cur.input.data.col.subset".
         cur.input.data.col.subset.na.omitted <- na.omit(object = cur.input.data.col.subset)
         ## Fit model.
         cur.model <- gam(formula = cur.formula,
		      family = kDistFamily,
		      data = cur.input.data.col.subset.na.omitted)
         ## Generate test data ##
         ## The test data should cover the same yield class range as the training data.
         ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
         SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
					"SI.h100" = NA)
         ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
         if (cur.species.name == "beech") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
         }
         if (cur.species.name == "spruce") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
         }
         ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
         for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	   SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	   SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
         }
         ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
         SI.h100.min <- min(cur.input.data[["SI.h100"]],
		        na.rm = TRUE)
         SI.h100.max <- max(cur.input.data[["SI.h100"]],
		        na.rm = TRUE)
         index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
         index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
         ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
         SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				   to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				   by = 0.1),
			     digits = 1)
         ## Initiate data frame in which to store test data.  The data frame will contain the following columns:
         ## - age
         ## - yield.class
         ## - h100
         ## - h100.EKL.I
         ## - SI.h100
         ## - SI.h100.diff.EKL.I
         test.df <- data.frame(NULL)
         ## Create age vector (required by all yield classes, so we make this assignment before starting the loop).
         age.vec <- seq(from = 0,
		    to = 160,
		    by = 1)
         ## Get SI.h100 value for yield class 1 (required by all yield classes, so we make this assignment before starting the loop).
         SI.h100.yield.class.1 <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == 1, "SI.h100"]
         ## Calculate h100 for yield class 1 using Nagel (1999), eq. (13) (required by all yield classes, so we make this assignment before starting the loop).
         h100.EKL.I.vec <- SI.h100.yield.class.1 * (beta3[[cur.species.name]] + beta4[[cur.species.name]] * log(x = age.vec)) + beta0[[cur.species.name]] + beta1[[cur.species.name]] * log(x = age.vec) + beta2[[cur.species.name]] * (log(x = age.vec)) ^ 2
         ## Loop over all yield classes required to cover the training data (i.e., the range from worst to best yield class needed).
         for (cur.yield.class in SI.h100.yield.class.values[index.worst.yield.class.needed:index.best.yield.class.needed, "yield.class"]) {
	   ## Get SI.h100 value for current yield class from "SI.h100.yield.class.values"
	   SI.h100.cur.yield.class <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == cur.yield.class, "SI.h100"]
	   ## Calculate h100 for the current yield class using Nagel (1999), eq. (13).
	   h100.vec <- SI.h100.cur.yield.class * (beta3[[cur.species.name]] + beta4[[cur.species.name]] * log(x = age.vec)) + beta0[[cur.species.name]] + beta1[[cur.species.name]] * log(x = age.vec) + beta2[[cur.species.name]] * (log(x = age.vec)) ^ 2
	   ## Calculate SI.h100 for the current yield class using Nagel (1999), eq. (13). [This procedure is a bit redundant, since it simply results in the "SI.h100.cur.yield.class" value defined above. I nevertheless opt for it, in order to make sure that the test data for sensitivity analysis is created in exactly the same way as the original data for model fitting was (cp. block "Create "gmax_merged_1.5.RData"").]
	   SI.h100.vec <- (h100.vec - beta0[[cur.species.name]] - beta1[[cur.species.name]] * log(x = age.vec) - beta2[[cur.species.name]] * ((log(x = age.vec)) ^ 2)) / (beta3[[cur.species.name]] + beta4[[cur.species.name]] * log(x = age.vec))
	   ## Calculate difference between SI.h100 value of current yield class and SI.h100 value of yield class 1.
	   SI.h100.diff.EKL.I.vec <- round(x = SI.h100.vec - SI.h100.yield.class.1, digits = 1)
	   ## Append the vectors for the current yield class to "test.df". 
	   test.df <- rbind(test.df,
			data.frame("age" = age.vec,
				 "yield.class" = as.factor(x = cur.yield.class),
				 "h100" = h100.vec,
				 "h100.EKL.I" = h100.EKL.I.vec,
				 "SI.h100" = SI.h100.vec,
				 "SI.h100.diff.EKL.I" = SI.h100.diff.EKL.I.vec))
         }
         ## Plot observations ##
         ## Initiate legend components.
         legend.legend <- vector(mode = "character")
         legend.pch <- vector(mode = "numeric")
         legend.lty <- vector(mode = "character")
         legend.lwd <- vector(mode = "numeric")
         legend.col <- vector(mode = "character")
         ## Generate a color palette of the same length as "SI.h100.sequence".
         cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Create empty plot.
         plot(x = cur.input.data[[kXValuesColumnNameTrainingData]],
	    type = "n",
	    xlim = kXLim,
	    ylim = kYLim,
	    xlab = kXLab,
	    ylab = kYLab,
	    main = cur.species.name.capitalized,
	    mgp = kPlotMgp,
	    xaxs = "i",
	    yaxs = "i",
	    panel.first = abline(v = seq(from = kXLim[1],
				   to = kXLim[2],
				   by = kGridIntervalV),
			     h  = seq(from = kYLim[1],
				    to = kYLim[2],
				    by = kGridIntervalH),
			     lty = kGridLineType,
			     lwd = kGridLineWidth,
			     col = kGridLineCol))
         ## Loop over all evdids.
         for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	   ## Create subset of "cur.input.data", based on current edvid.
	   edvid.subset <- subset(x = cur.input.data,
			      subset = edvid == cur.edvid)
	   ## Add lines for observations belonging to current edvid.
	   lines(x =edvid.subset[[kXValuesColumnNameTrainingData]],
	         y = edvid.subset[[kYValuesColumnNameTrainingData]],
	         lwd = kLineWidth,
	         lty = kLineType)
         }
         ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
         for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	   ## Create subset of "cur.input.data", based on current edvid.
	   edvid.subset <- subset(x = cur.input.data,
			      subset = edvid == cur.edvid)
	   ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	   SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
					table = SI.h100.sequence)
	   ## Add points to plot.
	   points(x = edvid.subset[[kXValuesColumnNameTrainingData]],
		y = edvid.subset[[kYValuesColumnNameTrainingData]],
		col = cur.species.color.palette[SI.h100.rounded.color.index],
		pch = kPointCharacter)
         }
         ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
         SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						       digits = 1),
					       table = SI.h100.sequence)
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        paste0("observations yield class ",
			     SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
         legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
         legend.pch <- c(legend.pch, rep(x = kPointCharacter, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
         legend.lty <- c(legend.lty, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
         legend.lwd <- c(legend.lwd, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
         ## Add model predictions to plot ##
         ## Get test data for current species.
         new.data <- test.df
         ## Restrict "new.data" to the columns of the independent variables of the current model.
         new.data <- subset(x = new.data,
		        select = all.vars(cur.formula)[-1])
         ## Calculate model predictions.
         new.data[[kYValuesColumnNameTestData]] <- predict(object = cur.model,
					         newdata = new.data,
					         what = "mu",
					         type = "response")
         ## Reattach columns "age", "h100", and "yield.class" to "new.data".
         new.data[["age"]] <- test.df[["age"]]
         new.data[["h100"]] <- test.df[["h100"]]
         new.data[["yield.class"]] <- test.df[["yield.class"]]
         ## Add lines to plot per yield class.
         all.cols <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
         for (cur.yield.class.index in seq_len(length.out = length(x = levels(x = new.data[["yield.class"]])))) {
	   yield.class.name <- levels(x = new.data[["yield.class"]])[cur.yield.class.index]
	   line.col <- all.cols[cur.yield.class.index]
	   lines(x = new.data[[kXValuesColumnNameTestData]][new.data[["yield.class"]] == yield.class.name],
	         y = new.data[[kYValuesColumnNameTestData]][new.data[["yield.class"]] == yield.class.name],
	         col = line.col,
	         lty = kLineType,
	         lwd = kLineWidth)
         }
         ## Add box around plot.
         box(bty = "o")
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        paste0("predictions yield class ",
			     SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
         legend.col <- c(legend.col,
		     cur.species.color.palette[SI.h100.yield.class.values.color.index])
         legend.pch <- c(legend.pch,
		     rep(x = NA,
		         times = length(x = SI.h100.yield.class.values[["yield.class"]])))
         legend.lty <- c(legend.lty,
		     rep(x = kLineType,
		         times = length(x = SI.h100.yield.class.values[["yield.class"]])))
         legend.lwd <- c(legend.lwd,
		     rep(x = kLineWidth,
		         times = length(x = SI.h100.yield.class.values[["yield.class"]])))
         ## Add legend.
         legend(x = kLegendX[[cur.species.name]],
	      ncol = kLegendNcol,
	      legend = legend.legend,
	      col = legend.col,
	      pch = legend.pch,
	      lty = legend.lty,
	      lwd = legend.lwd,
	      bg = kLegendBg)
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.                                   
     rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
** GAM2TopHeightBasalAreaObservationsPredictionsYieldClassClassification.pdf
   #+NAME: GAM2TopHeightBasalAreaObservationsPredictionsYieldClassClassification.pdf
   #+BEGIN_SRC R :results silent :var input=GAM2Preamble :session *MasArThesisRConsole*
     ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/GAM2Results.tex
     ## Plotting preamble ##
     kPlotMargins <- c(3, 3.25, 2, 1)
     kPlotMgp <- c(2, 1, 0)
     kPlotLayout <- matrix(data = 1:2,
		       nrow = 2,
		       ncol = 1)
     kLegendNcol <- 2
     kXLim <- c(0, 55)
     kYLim <- c(0, 85)
     kGridIntervalV <- 5
     kGridIntervalH <- 10
     kLegendX <- list("beech" = "topleft",
		  "spruce" = "bottomright")
     kXValuesColumnNameTrainingData <- "h100"
     kXValuesColumnNameTestData <- "h100"
     kYValuesColumnNameTrainingData <- "gha"
     kYValuesColumnNameTestData <- "gha.predictions"
     kXLab <- expression(italic("h")["100"]*" [m]")
     kYLab <- expression(italic("G")*" ["*m^2*" ha"^-1*"]")
     ## Create file name.
     kFilename <-paste0(kGraphicsSubsubdir,
		    paste0(kModelID, "TopHeightBasalAreaObservationsPredictionsYieldClassClassification.pdf"))
     ## Define color palette generating function.
     kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
     ## Set best yield class level for which to interpolate SI.h100 values.
     kBestYieldClassLevel <- -2
     ## Turn off graphics device.
     graphics.off()
     ## Start graphics device driver for producing PDF graphics.
     pdf(file = kFilename,
         width = kPdfWidthA4Portrait,
         height = kPdfHeightA4Portrait * 0.85,
         pointsize = kPdfPointSize,
         family = kPdfFamily)
     ## Set plot layout.
     layout(mat = kPlotLayout)
     ## Loop over species names.
     for (cur.species.name in kSpeciesNames) {
         ## Get capitalized name for current species.
         cur.species.name.capitalized <- kSpeciesNamesCapitalized[[cur.species.name]]
         ## Fit model ##
         ## Get input data frame for current species.
         cur.input.data <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
         ## Subset input data frame to the variables mentioned in the model formula.
         cur.input.data.col.subset <- cur.input.data[, all.vars(expr = cur.formula)]
         ## Remove missing values from "cur.input.data.col.subset".
         cur.input.data.col.subset.na.omitted <- na.omit(object = cur.input.data.col.subset)
         ## Fit model.
         cur.model <- gam(formula = cur.formula,
		      family = kDistFamily,
		      data = cur.input.data.col.subset.na.omitted)
         ## Generate test data ##
         ## The test data should cover the same yield class range as the training data.
         ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
         SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
					"SI.h100" = NA)
         ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
         if (cur.species.name == "beech") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
         }
         if (cur.species.name == "spruce") {
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
         }
         ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
         for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	   SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	   SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	   SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
         }
         ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
         SI.h100.min <- min(cur.input.data[["SI.h100"]],
		        na.rm = TRUE)
         SI.h100.max <- max(cur.input.data[["SI.h100"]],
		        na.rm = TRUE)
         index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
         index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
         ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
         SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				   to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				   by = 0.1),
			     digits = 1)
         ## Initiate data frame in which to store test data.  The data frame will contain the following columns:
         ## - age
         ## - yield.class
         ## - h100
         ## - h100.EKL.I
         ## - SI.h100
         ## - SI.h100.diff.EKL.I
         test.df <- data.frame(NULL)
         ## Create age vector (required by all yield classes, so we make this assignment before starting the loop).
         age.vec <- seq(from = 0,
		    to = 160,
		    by = 1)
         ## Get SI.h100 value for yield class 1 (required by all yield classes, so we make this assignment before starting the loop).
         SI.h100.yield.class.1 <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == 1, "SI.h100"]
         ## Calculate h100 for yield class 1 using Nagel (1999), eq. (13) (required by all yield classes, so we make this assignment before starting the loop).
         h100.EKL.I.vec <- SI.h100.yield.class.1 * (beta3[[cur.species.name]] + beta4[[cur.species.name]] * log(x = age.vec)) + beta0[[cur.species.name]] + beta1[[cur.species.name]] * log(x = age.vec) + beta2[[cur.species.name]] * (log(x = age.vec)) ^ 2
         ## Loop over all yield classes required to cover the training data (i.e., the range from worst to best yield class needed).
         for (cur.yield.class in SI.h100.yield.class.values[index.worst.yield.class.needed:index.best.yield.class.needed, "yield.class"]) {
	   ## Get SI.h100 value for current yield class from "SI.h100.yield.class.values"
	   SI.h100.cur.yield.class <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == cur.yield.class, "SI.h100"]
	   ## Calculate h100 for the current yield class using Nagel (1999), eq. (13).
	   h100.vec <- SI.h100.cur.yield.class * (beta3[[cur.species.name]] + beta4[[cur.species.name]] * log(x = age.vec)) + beta0[[cur.species.name]] + beta1[[cur.species.name]] * log(x = age.vec) + beta2[[cur.species.name]] * (log(x = age.vec)) ^ 2
	   ## Calculate SI.h100 for the current yield class using Nagel (1999), eq. (13). [This procedure is a bit redundant, since it simply results in the "SI.h100.cur.yield.class" value defined above. I nevertheless opt for it, in order to make sure that the test data for sensitivity analysis is created in exactly the same way as the original data for model fitting was (cp. block "Create "gmax_merged_1.5.RData"").]
	   SI.h100.vec <- (h100.vec - beta0[[cur.species.name]] - beta1[[cur.species.name]] * log(x = age.vec) - beta2[[cur.species.name]] * ((log(x = age.vec)) ^ 2)) / (beta3[[cur.species.name]] + beta4[[cur.species.name]] * log(x = age.vec))
	   ## Calculate difference between SI.h100 value of current yield class and SI.h100 value of yield class 1.
	   SI.h100.diff.EKL.I.vec <- round(x = SI.h100.vec - SI.h100.yield.class.1, digits = 1)
	   ## Append the vectors for the current yield class to "test.df". 
	   test.df <- rbind(test.df,
			data.frame("age" = age.vec,
				 "yield.class" = as.factor(x = cur.yield.class),
				 "h100" = h100.vec,
				 "h100.EKL.I" = h100.EKL.I.vec,
				 "SI.h100" = SI.h100.vec,
				 "SI.h100.diff.EKL.I" = SI.h100.diff.EKL.I.vec))
         }
         ## Plot observations ##
         ## Initiate legend components.
         legend.legend <- vector(mode = "character")
         legend.pch <- vector(mode = "numeric")
         legend.lty <- vector(mode = "character")
         legend.lwd <- vector(mode = "numeric")
         legend.col <- vector(mode = "character")
         ## Generate a color palette of the same length as "SI.h100.sequence".
         cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
         ## Set plot margins.
         par("mar" = kPlotMargins)
         ## Create empty plot.
         plot(x = cur.input.data[[kXValuesColumnNameTrainingData]],
	    type = "n",
	    xlim = kXLim,
	    ylim = kYLim,
	    xlab = kXLab,
	    ylab = kYLab,
	    main = cur.species.name.capitalized,
	    mgp = kPlotMgp,
	    xaxs = "i",
	    yaxs = "i",
	    panel.first = abline(v = seq(from = kXLim[1],
				   to = kXLim[2],
				   by = kGridIntervalV),
			     h  = seq(from = kYLim[1],
				    to = kYLim[2],
				    by = kGridIntervalH),
			     lty = kGridLineType,
			     lwd = kGridLineWidth,
			     col = kGridLineCol))
         ## Loop over all evdids.
         for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	   ## Create subset of "cur.input.data", based on current edvid.
	   edvid.subset <- subset(x = cur.input.data,
			      subset = edvid == cur.edvid)
	   ## Add lines for observations belonging to current edvid.
	   lines(x =edvid.subset[[kXValuesColumnNameTrainingData]],
	         y = edvid.subset[[kYValuesColumnNameTrainingData]],
	         lwd = kLineWidth,
	         lty = kLineType)
         }
         ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
         for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	   ## Create subset of "cur.input.data", based on current edvid.
	   edvid.subset <- subset(x = cur.input.data,
			      subset = edvid == cur.edvid)
	   ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	   SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
					table = SI.h100.sequence)
	   ## Add points to plot.
	   points(x = edvid.subset[[kXValuesColumnNameTrainingData]],
		y = edvid.subset[[kYValuesColumnNameTrainingData]],
		col = cur.species.color.palette[SI.h100.rounded.color.index],
		pch = kPointCharacter)
         }
         ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
         SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						       digits = 1),
					       table = SI.h100.sequence)
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        paste0("observations yield class ",
			     SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
         legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
         legend.pch <- c(legend.pch, rep(x = kPointCharacter, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
         legend.lty <- c(legend.lty, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
         legend.lwd <- c(legend.lwd, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
         ## Add model predictions to plot ##
         ## Get test data for current species.
         new.data <- test.df
         ## Restrict "new.data" to the columns of the independent variables of the current model.
         new.data <- subset(x = new.data,
		        select = all.vars(cur.formula)[-1])
         ## Calculate model predictions.
         new.data[[kYValuesColumnNameTestData]] <- predict(object = cur.model,
					         newdata = new.data,
					         what = "mu",
					         type = "response")
         ## Reattach columns "age", "h100", and "yield.class" to "new.data".
         new.data[["age"]] <- test.df[["age"]]
         new.data[["h100"]] <- test.df[["h100"]]
         new.data[["yield.class"]] <- test.df[["yield.class"]]
         ## Add lines to plot per yield class.
         all.cols <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
         for (cur.yield.class.index in seq_len(length.out = length(x = levels(x = new.data[["yield.class"]])))) {
	   yield.class.name <- levels(x = new.data[["yield.class"]])[cur.yield.class.index]
	   line.col <- all.cols[cur.yield.class.index]
	   lines(x = new.data[[kXValuesColumnNameTestData]][new.data[["yield.class"]] == yield.class.name],
	         y = new.data[[kYValuesColumnNameTestData]][new.data[["yield.class"]] == yield.class.name],
	         col = line.col,
	         lty = kLineType,
	         lwd = kLineWidth)
         }
         ## Add box around plot.
         box(bty = "o")
         ## Update legend components.
         legend.legend <- c(legend.legend,
		        paste0("predictions yield class ",
			     SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
         legend.col <- c(legend.col,
		     cur.species.color.palette[SI.h100.yield.class.values.color.index])
         legend.pch <- c(legend.pch,
		     rep(x = NA,
		         times = length(x = SI.h100.yield.class.values[["yield.class"]])))
         legend.lty <- c(legend.lty,
		     rep(x = kLineType,
		         times = length(x = SI.h100.yield.class.values[["yield.class"]])))
         legend.lwd <- c(legend.lwd,
		     rep(x = kLineWidth,
		         times = length(x = SI.h100.yield.class.values[["yield.class"]])))
         ## Add legend.
         legend(x = kLegendX[[cur.species.name]],
	      ncol = kLegendNcol,
	      legend = legend.legend,
	      col = legend.col,
	      pch = legend.pch,
	      lty = legend.lty,
	      lwd = legend.lwd,
	      bg = kLegendBg)
     }
     ## Turn off graphics device.
     graphics.off()
     ## Clean up workspace.                                   
     rm(list = setdiff(x = ls(), y = objects.at.script.start))
   #+END_SRC
* TopHeightBasalAreaYieldClassClassification.pdf
  #+NAME: TopHeightBasalAreaYieldClassClassification.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/DataDescription.tex
    ## Plotting preamble.
    kPlotMargins <- c(3, 3.25, 2, 1)
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:2,
		      nrow = 2,
		      ncol = 1)
    kLegendX <- "topleft"
    kXLim <- c(0, 40)
    kYLim <- c(0, 85)
    kGridIntervalV <- 5
    kGridIntervalH <- 10
    kXValuesColumnName <- "h100"
    kYValuesColumnName <- "gha"
    kXLab <- expression(italic("h")["100"]*" [m]")
    kYLab <- expression(italic("G")*" ["*m^2*" ha"^-1*"]")
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Turn off graphics device.
    graphics.off()
    ## Create file name.
    file.name <-paste0(kGraphicsSubdir,
		   "TopHeightBasalAreaYieldClassClassification.pdf")
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = file.name,
        width = kPdfWidthA4Portrait,
        height = kPdfHeightA4Portrait * 0.85,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Loop over all species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get data frame for current species.
        bart.cur.species.clean.1.8 <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
        SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				         "SI.h100" = NA)
        ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
        if (cur.species.name == "beech") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
        }
        if (cur.species.name == "spruce") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
        }
        ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
        for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	  SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	  SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
        }
        ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
        SI.h100.min <- min(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        SI.h100.max <- max(bart.cur.species.clean.1.8[["SI.h100"]],
		       na.rm = TRUE)
        index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
        index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
        ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
        SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				  to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				  by = 0.1),
			    digits = 1)
        ## Generate a color palette of the same length as "SI.h100.sequence".
        cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
        ## Set plot margins.
        par("mar" = kPlotMargins)
        ## Create empty plot.
        plot(x = bart.cur.species.clean.1.8[[kXValuesColumnName]],
	   type = "n",
	   xlim = kXLim,
	   ylim = kYLim,
	   xlab = kXLab,
	   ylab = kYLab,
	   main = kSpeciesNamesCapitalized[[cur.species.name]],
	   mgp = kPlotMgp,
	   xaxs = "i",
	   yaxs = "i",
	   panel.first = abline(v = seq(from = kXLim[1],
				  to = kXLim[2],
				  by = kGridIntervalV),
			    h  = seq(from = kYLim[1],
				   to = kYLim[2],
				   by = kGridIntervalH),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Loop over all evdids.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Add lines for observations belonging to current edvid.
	  lines(x =edvid.subset[[kXValuesColumnName]],
	        y = edvid.subset[[kYValuesColumnName]],
	        lwd = kLineWidth,
	        lty = kLineType)
        }
        ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
        for (cur.edvid in levels(x = bart.cur.species.clean.1.8[["edvid"]])) {
	  ## Create subset of "bart.cur.species.clean.1.8", based on current edvid.
	  edvid.subset <- subset(x = bart.cur.species.clean.1.8,
			     subset = edvid == cur.edvid)
	  ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	  SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				         table = SI.h100.sequence)
	  ## Add points to plot.
	  points(x = edvid.subset[[kXValuesColumnName]],
	         y = edvid.subset[[kYValuesColumnName]],
	         col = cur.species.color.palette[SI.h100.rounded.color.index],
	         pch = kPointCharacter)
        }
        ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
        SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						      digits = 1),
					      table = SI.h100.sequence)
        ## Add legend.
        legend.legend <- c(paste0("yield class ",
			    SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        legend.col <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
        legend.pch <- kPointCharacter
        legend(x = kLegendX,
	     legend = legend.legend,
	     col = legend.col,
	     pch = legend.pch,
	     bg = kLegendBg)
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* File local variables
  # Local Variables:
  # End:

