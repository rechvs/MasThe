#+STARTUP: hideblocks
* Preamble
  #+NAME: Preamble
  #+BEGIN_SRC R :results silent :session *MasArPresentationRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/MasAr_Thesis.tex
    rm(list = ls())
    setwd(dir = "~/laptop02_MasAr")
    kDataDir <- "Data/"
    ## Load data set.
    kBaseFileVersion <- "5.3"
    kBaseFileName <- paste0(kDataDir, "gmax_merged_", kBaseFileVersion, ".RData")
    kgmaxObjects <- load(file = kBaseFileName, verbose = TRUE)
    ## Set dimensions of PDF device.
    kPtToCm <- 0.035146
    kPdfWidthSlide <- 358.50484 * kPtToCm  ## Use "\the\textwidth" in LaTeX document to find out total text width.
    kPdfHeightSlide <- 233.49104 * kPtToCm  ## Use "\the\textheight" in LaTeX document to find out total text height.
    ## Set point size for PDF device.
    kPdfPointSize <- 9
    ## Set font family for PDF device.
    kPdfFamily <- "Helvetica"
    ## Set standard point character for plots.
    kPointCharacter <- 20
    ## Set standard line settings for plots.
    kLineWidth <- 1
    kLineType <- "solid"
    ## Set a distinct color for each species to use in all multi-species plots. Colors are taken from NiedersÃ¤chsische Landesforsten (2011), fig. 3.
    kSpeciesColors <- list("beech" = "#ee7f00",
		       "spruce" = "#4066aa")
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set plot grid properties.
    kGridLineType <- "dashed"
    kGridLineCol <- "gray"
    kGridLineWidth <- 0.5
    ## Set background color for plot legends.
    kLegendBg <- "gray"
    ## Set vectors of species names.
    kSpeciesNames <- c("beech", "spruce")
    kSpeciesNamesCapitalized <- c("Beech", "Spruce")
    ## Define segmented functions.
    rhs <- function (x, c) {
        return(ifelse(test = x > c,
		  yes = x-c,
		  no = 0))
    }
    lhs <- function (x, c) {
        return(ifelse(test = x <= c,
		  yes = c-x,
		  no = 0))
    }
    ## Set model formulas for the unconstrained GAMLSS, depending on species.
    kUnconstrainedFormulas <- list(as.formula(object = "gha ~ ps(h100.EKL.I) + ps(SI.h100.diff.EKL.I)"),
			     as.formula(object = "gha ~ ps(h100.EKL.I) + ps(SI.h100.diff.EKL.I)"))
    names(x = kUnconstrainedFormulas) <- kSpeciesNames
    ## Set model formulas for the constrained GAMLSS, depending on species.
    kConstrainedFormulas <- list(as.formula(object = "gha ~ pbm(h100.EKL.I) + SI.h100.diff.EKL.I"),
			   as.formula(object = "gha ~ lhs(x = h100.EKL.I, c = 22) + SI.h100.diff.EKL.I"))
    names(x = kConstrainedFormulas) <- kSpeciesNames
    ## Set destination directory for output.
    kOutputSubdir <- "R/Output/Presentation/"
    ## Set destination directory for graphics.
    kGraphicsSubdir <- "Graphics/Presentation/"
    ## If nonexistent, create all required directories.
    system2(command = "mkdir",
	  args = paste0("-p ", c(kGraphicsSubdir, kOutputSubdir)))
    objects.at.script.start <- c(ls(), "objects.at.script.start")  ## Required for cleaning up workspace.
  #+END_SRC
* logDlogNPlotsBeforeAfterDataSelectionBeech.pdf
  #+NAME: logDlogNPlotsBeforeAfterDataSelectionBeech.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArPresentationRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Presentation/DataSelection.tex
    ## This script creates 2 plots in one file in a 1-by-2 layout (one row per species, one column per data selection state), showing the effect of the data selection mechanism.
    ## Plotting preamble.
    kPlotMgp <- c(2, 1, 0)
    kXLab <- expression(paste("log(", italic("D"), ")"))
    kYLab <- expression(paste("log(", italic("N"), ")"))
    kXMin <- list("beech" = 0.8,
	        "spruce" = 0.8)
    kXMax <- list("beech" = 1.8,
	        "spruce" = 1.8)
    kYMin <- list("beech" = 1.6,
	        "spruce" = 2.4 * 0.9)
    kYMax <- list("beech" = 3.6,
	        "spruce" = 3.6)
    kPlotLayout <- 1:2
    kUpperThresholdLineType <- "dashed"
    kLowerThresholdLineType <- "solid"
    kThresholdLinesFrom <- 0
    kThresholdLinesTo <- 10
    kThresholdLinesCol <- "black"
    ## Loop over all species names.
    for (cur.species.name in "beech") {
        ## Turn off graphics device.
        graphics.off()
        ## Create file name.
        file.name <-paste0(kGraphicsSubdir,
		       "logDlogNPlotsBeforeAfterDataSelectionBeech.pdf")
        ## Start graphics device driver for producing PDF graphics.
        pdf(file = file.name,
	  width = kPdfWidthSlide / 2,
	  height = kPdfHeightSlide / 2 * 0.9,
	  pointsize = kPdfPointSize,
	  family = kPdfFamily)
        ## Set plot layout to 1-by-2.
        layout(mat = matrix(data = kPlotLayout,
		        nrow = 1,
		        ncol = 2,
		        byrow = TRUE))
        ## Loop over all plot numbers.
        for (cur.plot.nr in kPlotLayout) {
	  ## Define plot margins, depending on which plot are at.
	  if (cur.plot.nr == 1) {
	      left.margin <- 3.25
	      right.margin <- 0
	  } else {
	      left.margin <- 2
	      right.margin <- 1
	  }
	  ## Set plot margins.
	  par("mar" = c(3.5, left.margin, 1, right.margin))
	  ## Extract x- and y-limits for current species.
	  cur.xmin <- as.numeric(x = kXMin[names(x = kXMin) == cur.species.name])
	  cur.xmax <- as.numeric(x = kXMax[names(x = kXMax) == cur.species.name])
	  cur.ymin <- as.numeric(x = kYMin[names(x = kYMin) == cur.species.name])
	  cur.ymax <- as.numeric(x = kYMax[names(x = kYMax) == cur.species.name])
	  ## Set point and line color for current species.
	  cur.point.line.col <- as.character(x = kSpeciesColors[names(x = kSpeciesColors) == cur.species.name])
	  ## Set data frame version for current plot number ("1.0" for plots number 1 and 3, "1.8" for plots number 2 and 4).
	  cur.data.frame.version <- ifelse(test = cur.plot.nr %% 2 != 0,
				     yes = "1.0",
				     no = "1.8")
	  ## Get data frame for current species and plot number.
	  cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.", cur.data.frame.version))
	  ## Select column specifier for current plot ("A" for plot number 1, "B" for plot number 2, "" for plots number 3 and 4).
	  if (cur.plot.nr <=2) {
	      cur.plot.main <- ifelse(test = cur.plot.nr %% 2 != 0,
				yes = "A",
				no = "B")
	  } else {
	      cur.plot.main <- ""
	  }
	  ## Set x-axis label for current plot ("" for plots number 1 and 2, kXLab for plots number 3 and 4).
	  cur.xlab <- ifelse(test = cur.plot.nr <= 2,
			 yes = "",
			 no = kXLab)
	  ## Set y-axis label for current plot (kYLab for plots number 1 and 3, "" for plots number 2 and 4).
	  cur.ylab <- ifelse(test = cur.plot.nr %% 2 != 0,
			 yes = kYLab,
			 no = "")
	  ## Initiate legend components.
	  legend.legend <- vector(mode = "character")
	  legend.pch <- vector(mode = "numeric")
	  legend.lty <- vector(mode = "character")
	  legend.lwd <- vector(mode = "numeric")
	  legend.col <- vector(mode = "character")
	  ## Create empty plot.
	  plot(x = 0,
	       type = "n",
	       xlim = c(cur.xmin, cur.xmax),
	       ylim = c(cur.ymin, cur.ymax),
	       xlab = kXLab,
	       ## xlab = cur.xlab,
	       ## ylab = kYLab,
	       ylab = cur.ylab,
	       xaxs = "i",
	       yaxs = "i",
	       mgp = kPlotMgp,
	       main = cur.plot.main,
	       panel.first = abline(v = seq(from = 0,
				      to = 2,
				      by = 0.2),
			        h = seq(from = 0,
				      to = 4,
				      by = 0.2),
			        lty = kGridLineType,
			        lwd = kGridLineWidth,
			        col = kGridLineCol))
	  ## Define function for calculating the lines representing the slope thresholds.
	  slope.threshold.func <- function(s, x, k) {
	      res <- s * x + k
	      return(res)
	  }
	  ## Add line for upper slope threshold to plot.
	  cur.species.upper.slope.threshold <- ifelse(test = cur.species.name == "beech",
					      yes = -0.9,
					      no = -0.65)
	  cur.species.threshold.func.upper.intercept <- cur.ymax - cur.species.upper.slope.threshold * cur.xmin
	  curve(expr = slope.threshold.func(s = cur.species.upper.slope.threshold,
				      x,
				      k = cur.species.threshold.func.upper.intercept),
	        from = kThresholdLinesFrom,
	        to = kThresholdLinesTo,
	        lty = kUpperThresholdLineType,
	        lwd = kLineWidth,
	        col = kThresholdLinesCol,
	        add = TRUE)
	  ## Update legend components.
	  legend.legend <- c(legend.legend, expression(italic("m")[o]))
	  legend.pch <- c(legend.pch, NA)
	  legend.lty <- c(legend.lty, kUpperThresholdLineType)
	  legend.lwd <- c(legend.lwd, kLineWidth)
	  legend.col <- c(legend.col, kThresholdLinesCol)
	  ## Add line for lower slope threshold to plot.
	  cur.species.lower.slope.threshold <- ifelse(test = cur.species.name == "beech",
					      yes = -2.91,
					      no = -2.82)
	  cur.species.threshold.func.lower.intercept <- cur.ymax - cur.species.lower.slope.threshold * cur.xmin
	  curve(expr = slope.threshold.func(s = cur.species.lower.slope.threshold,
				      x,
				      k = cur.species.threshold.func.lower.intercept),
	        from = kThresholdLinesFrom,
	        to = kThresholdLinesTo,
	        lty = kLowerThresholdLineType,
	        lwd = kLineWidth,
	        col = kThresholdLinesCol,
	        add = TRUE)
	  ## Update legend components.
	  legend.legend <- c(legend.legend, expression(italic("m")[u]))
	  legend.pch <- c(legend.pch, NA)
	  legend.lty <- c(legend.lty, kLowerThresholdLineType)
	  legend.lwd <- c(legend.lwd, kLineWidth)
	  legend.col <- c(legend.col, kThresholdLinesCol)
	  ## Loop over all "edvid"s.
	  for (cur.edvid.name in levels(x = cur.data.frame[["edvid"]])) {
	      ## Extract x-values for current "edvid".
	      cur.x.values <- cur.data.frame[["log.dg"]][cur.data.frame[["edvid"]] == cur.edvid.name]
	      ## Extract y-values for current "edvid".
	      cur.y.values <- cur.data.frame[["log.nha"]][cur.data.frame[["edvid"]] == cur.edvid.name]
	      ## Add points to plot per "edvid", with distinct colors per species.
	      points(x = cur.x.values,
		   y = cur.y.values,
		   type = "p",
		   pch = kPointCharacter,
		   lty = kLineType,
		   col = cur.point.line.col)
	      ## Add lines to plot per "edvid", with distinct colors per species.
	      lines(x = cur.x.values,
		  y = cur.y.values,
		  lty = kLineType,
		  lwd = kLineWidth,
		  col = cur.point.line.col)
	  }
	  ## Calculate number of observations in current data frame.
	  cur.n <- nrow(x = cur.data.frame)
	  ## Calculate number of sample plots in current data frame.
	  cur.sample.plots.n <- length(x = levels(x = droplevels(x = cur.data.frame[["edvid"]])))
	  ## Update legend components. I am adding 2 elements to each legend component because itâs the only way to insert a line break between the string "Beobachtungen" and the expression containing "cur.n" and "cur.sample.plots.n".
	  legend.legend <- c(legend.legend,
			 "Beobachtungen")
	  legend.pch <- c(legend.pch, kPointCharacter)
	  legend.lty <- c(legend.lty, kLineType)
	  legend.lwd <- c(legend.lwd, kLineWidth)
	  legend.col <- c(legend.col, cur.point.line.col)
	  legend.legend <- c(legend.legend,
			 mapply(FUN = function(expr1, numbr1, expr2, numbr2) { as.expression(x = bquote(.(expr1)*.(numbr1)*", "*.(expr2)*.(numbr2)*")")) },
	 expr1 = expression("("*italic("n")["Beob"]*" = "),
	 numbr1 = cur.n,
	 expr2 = expression(italic("n")["Parz"]*" = "),
	 numbr2 = cur.sample.plots.n
	 ))
	  legend.pch <- c(legend.pch, NA)
	  legend.lty <- c(legend.lty, NA)
	  legend.lwd <- c(legend.lwd, NA)
	  legend.col <- c(legend.col, NA)
	  ## Add legend.
	  legend(x = "bottomleft",
	         legend = legend.legend,
	         col = legend.col,
	         lty = legend.lty,
	         pch = legend.pch,
	         lwd = legend.lwd,
	         bg = "gray")
	  ## Reset legend components.
	  legend.legend <- vector(mode = "character")
	  legend.pch <- vector(mode = "numeric")
	  legend.lty <- vector(mode = "character")
	  legend.lwd <- vector(mode = "numeric")
	  legend.col <- vector(mode = "character")
        }
        ## Turn off graphics device.
        graphics.off()
    }
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* TermEffectsGAMLSSUnconstrained.pdf
  #+NAME: TermEffectsGAMLSSUnconstrained.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArPresentationRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Presentation/Modelling.tex
    ## Plotting preamble ##
    #######################
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:4,
		      nrow = 2,
		      ncol = 2)
    kLegendNcol <- 2
    kXLim <- c(0, 160)
    kYLim <- c(0, 85)
    ## Create file name.
    kFilename <-paste0(kGraphicsSubdir,
		   "TermEffectsGAMLSSUnconstrained.pdf")
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Modelling preamble ##
    ########################
    library(package = "gamlss")
    ## Turn off graphics device.
    graphics.off()
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = kFilename,
        width = kPdfWidthSlide / 2,
        height = kPdfHeightSlide / 2 * 0.9,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Set graphical parameters.
    par("mgp" = kPlotMgp)
    ## Loop over species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get translated version of current species name.
        if (cur.species.name == "beech") {
	  cur.species.name.translated <- "Buche"
        }
        if (cur.species.name == "spruce") {
	  cur.species.name.translated <- "Fichte"
        }
        ## Fit model ##
    ###############
        ## Get unconstrained model formula for current species.
        cur.formula <- kUnconstrainedFormulas[[cur.species.name]]
        ## Get input data frame for current species.
        cur.input.data <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Subset input data frame to the variables mentioned in the model formula.
        cur.input.data.col.subset <- cur.input.data[, all.vars(expr = cur.formula)]
        ## Remove missing values from "cur.input.data.col.subset".
        cur.input.data.col.subset.na.omitted <- na.omit(object = cur.input.data.col.subset)
        ## Fit model.
        cur.model <- gamlss::gamlss(formula = cur.formula,
			      sigma.formula = "gha ~ 1",
			      nu.formula = "gha ~ 1",
			      tau.formula = "gha ~ 1",
			      family = gamlss.dist::BCCGo(),
			      data = cur.input.data.col.subset.na.omitted,
			      method = RS(1000))
        ## Loop over model term indexes for current model.
        for (cur.term.index in 1:2) {
	  ## Get current model term.
	  cur.model.term <- attr(x = terms(x = formula(x = cur.model, what = "mu")), which = "term.labels")[cur.term.index]
	  ## Define plot main title and plot margins, depending on which term index (and thus which plot) we are at.
	  if (cur.term.index %% 2 != 0) {
	      cur.plot.main.title <- cur.species.name.translated
	      top.margin <- 2
	  } else {
	      cur.plot.main.title <- ""
	      top.margin <- 0
	  }
	  ## Set y-axis label and plot margins, depending on which species (and thus which plot) we are at.
	  if (cur.species.name == kSpeciesNames[1]) {
	      cur.ylab <- paste0("Partial for ", cur.model.term)
	      left.margin <- 3.25
	  } else {
	      cur.ylab <- ""
	      left.margin <- 2
	  }
	  ## Set plot margins.
	  par("mar" = c(3, left.margin, top.margin, 0.25))
	  ## Plot model term effect ##
    ############################
	  gamlss::term.plot(object = cur.model,
			se = TRUE,
			scheme = "lines",
			partial.resid = FALSE,
			what = "mu",
			terms = cur.model.term,
			ylab = cur.ylab,
			pages = 0,
			ask = FALSE,
			data = cur.input.data.col.subset.na.omitted,
			rug = TRUE,
			main = cur.plot.main.title)
        }}
        ## Turn off graphics device.
        graphics.off()
  #+END_SRC
* TermEffectsGAMLSSConstrained.pdf
  #+NAME: TermEffectsGAMLSSConstrained.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArPresentationRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Presentation/Modelling.tex
    ## Plotting preamble ##
    #######################
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:4,
		      nrow = 2,
		      ncol = 2)
    kLegendNcol <- 2
    kXLim <- c(0, 160)
    kYLim <- c(0, 85)
    ## Create file name.
    kFilename <-paste0(kGraphicsSubdir,
		   "TermEffectsGAMLSSConstrained.pdf")
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Modelling preamble ##
    ########################
    library(package = "gamlss")
    ## Turn off graphics device.
    graphics.off()
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = kFilename,
        width = kPdfWidthSlide / 2,
        height = kPdfHeightSlide / 2 * 0.9,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Set graphical parameters.
    par("mgp" = kPlotMgp)
    ## Loop over species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get translated version of current species name.
        if (cur.species.name == "beech") {
	  cur.species.name.translated <- "Buche"
        }
        if (cur.species.name == "spruce") {
	  cur.species.name.translated <- "Fichte"
        }
        ## Fit model ##
    ###############
        ## Get constrained model formula for current species.
        cur.formula <- kConstrainedFormulas[[cur.species.name]]
        ## Get input data frame for current species.
        cur.input.data <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Subset input data frame to the variables mentioned in the model formula.
        cur.input.data.col.subset <- cur.input.data[, all.vars(expr = cur.formula)]
        ## Remove missing values from "cur.input.data.col.subset".
        cur.input.data.col.subset.na.omitted <- na.omit(object = cur.input.data.col.subset)
        ## Fit model.
        cur.model <- gamlss::gamlss(formula = cur.formula,
			      sigma.formula = "gha ~ 1",
			      nu.formula = "gha ~ 1",
			      tau.formula = "gha ~ 1",
			      family = gamlss.dist::BCCGo(),
			      data = cur.input.data.col.subset.na.omitted,
			      method = RS(1000))
        ## Loop over model term indexes for current model.
        for (cur.term.index in 1:2) {
	  ## Get current model term.
	  cur.model.term <- attr(x = terms(x = formula(x = cur.model, what = "mu")), which = "term.labels")[cur.term.index]
	  ## Define plot main title, y-axis label, and plot margins, depending on which term index (and thus which plot) we are at.
	  if (cur.term.index %% 2 != 0) {
	      cur.plot.main.title <- cur.species.name.translated
	      cur.ylab <- paste0("Partial for ", cur.model.term)
	      top.margin <- 2
	      if (cur.species.name == kSpeciesNames[1]) {
		left.margin <- 3.25
	      } else {
		left.margin <- 3.25
	      }
	  } else {
	      if (cur.species.name == kSpeciesNames[1]) {
		cur.ylab <- paste0("Partial for ", cur.model.term)
		left.margin <- 3.25
	      } else {
		cur.ylab <- ""
		left.margin <- 2
	      }
	      cur.plot.main.title <- ""
	      top.margin <- 0
	  }
	  ## Set plot margins.
	  par("mar" = c(3, left.margin, top.margin, 0.25))
	  ## Plot model term effect ##
    ############################
	  gamlss::term.plot(object = cur.model,
			se = TRUE,
			scheme = "lines",
			partial.resid = FALSE,
			what = "mu",
			terms = cur.model.term,
			ylab = cur.ylab,
			pages = 0,
			ask = FALSE,
			data = cur.input.data.col.subset.na.omitted,
			rug = TRUE,
			main = cur.plot.main.title)
        }}
        ## Turn off graphics device.
        graphics.off()
  #+END_SRC
* StandAgeBasalAreaObservationsGAMLSSUnconstrainedPredictions.pdf
  #+NAME: StandAgeBasalAreaObservationsGAMLSSUnconstrainedPredictions.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArPresentationRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Presentation/Modelling.tex
    ## Plotting preamble ##
    #######################
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:2,
		      nrow = 1,
		      ncol = 2)
    kLegendNcol <- 2
    kXLim <- c(0, 160)
    kYLim <- c(0, 85)
    ## Create file name.
    kFilename <-paste0(kGraphicsSubdir,
		   "StandAgeBasalAreaObservationsGAMLSSUnconstrainedPredictions.pdf")
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Modelling preamble ##
    ########################
    library(package = "gamlss")
    ## Turn off graphics device.
    graphics.off()
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = kFilename,
        width = kPdfWidthSlide / 2,
        height = kPdfHeightSlide / 2 * 0.9,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Loop over species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get translated version of current species name.
        if (cur.species.name == "beech") {
	  cur.species.name.capitalized <- "Buche"
        }
        if (cur.species.name == "spruce") {
	  cur.species.name.capitalized <- "Fichte"
        }
        ## Fit model ##
    ###############
        ## Get unconstrained model formula for current species.
        cur.formula <- kUnconstrainedFormulas[[cur.species.name]]
        ## Get input data frame for current species.
        cur.input.data <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Subset input data frame to the variables mentioned in the model formula.
        cur.input.data.col.subset <- cur.input.data[, all.vars(expr = cur.formula)]
        ## Remove missing values from "cur.input.data.col.subset".
        cur.input.data.col.subset.na.omitted <- na.omit(object = cur.input.data.col.subset)
        ## Fit model.
        cur.model <- gamlss::gamlss(formula = cur.formula,
			      sigma.formula = "gha ~ 1",
			      nu.formula = "gha ~ 1",
			      tau.formula = "gha ~ 1",
			      family = gamlss.dist::BCCGo(),
			      data = cur.input.data.col.subset.na.omitted,
			      method = RS(1000))
	  ## Generate test data ##
    ########################
        ## The test data should cover the same yield class range as the training data.
        ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
        SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				         "SI.h100" = NA)
        ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
        if (cur.species.name == "beech") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
        }
        if (cur.species.name == "spruce") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
        }
        ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
        for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	  SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	  SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
        }
        ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
        SI.h100.min <- min(cur.input.data[["SI.h100"]],
		       na.rm = TRUE)
        SI.h100.max <- max(cur.input.data[["SI.h100"]],
		       na.rm = TRUE)
        index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
        index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
        ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
        SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				  to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				  by = 0.1),
			    digits = 1)
        ## Initiate data frame in which to store test data.  The data frame will contain the following columns:
        ## - age
        ## - yield.class
        ## - h100
        ## - h100.EKL.I
        ## - SI.h100
        ## - SI.h100.diff.EKL.I
        test.df <- data.frame(NULL)
        ## Assign species-specific coefficients of Nagel function (taken from Nagel (1999), tab. 4).
        if (cur.species.name == "beech") {
	  hb0 <- -75.659
	  hb1 <- 23.192
	  hb2 <- -1.468
	  hb3 <- 0
	  hb4 <- 0.2152
        }
        if (cur.species.name == "spruce") {
	  hb0 <- -49.872
	  hb1 <- 7.3309
	  hb2 <- 0.77338
	  hb3 <- 0.52684
	  hb4 <- 0.10542
        }
        ## Create age vector (required by all yield classes, so we make this assignment before starting the loop).
        age.vec <- seq(from = 10,
		   to = 160,
		   by = 1)
        ## Get SI.h100 value for yield class 1 (required by all yield classes, so we make this assignment before starting the loop).
        SI.h100.yield.class.1 <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == 1, "SI.h100"]
        ## Calculate h100 for yield class 1 using Nagel (1999), eq. (13) (required by all yield classes, so we make this assignment before starting the loop).
        h100.EKL.I.vec <- SI.h100.yield.class.1 * (hb3 + hb4 * log(x = age.vec)) + hb0 + hb1 * log(x = age.vec) + hb2 * (log(x = age.vec)) ^ 2
        ## Loop over all yield classes required to cover the training data (i.e., the range from worst to best yield class needed).
        for (cur.yield.class in SI.h100.yield.class.values[index.worst.yield.class.needed:index.best.yield.class.needed, "yield.class"]) {
	  ## Get SI.h100 value for current yield class from "SI.h100.yield.class.values"
	  SI.h100.cur.yield.class <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == cur.yield.class, "SI.h100"]
	  ## Calculate h100 for the current yield class using Nagel (1999), eq. (13).
	  h100.vec <- SI.h100.cur.yield.class * (hb3 + hb4 * log(x = age.vec)) + hb0 + hb1 * log(x = age.vec) + hb2 * (log(x = age.vec)) ^ 2
	  ## Calculate SI.h100 for the current yield class using Nagel (1999), eq. (13). [This procedure is a bit redundant, since it simply results in the "SI.h100.cur.yield.class" value defined above. I nevertheless opt for it, in order to make sure that the test data for sensitivity analysis is created in exactly the same way as the original data for model fitting was (cp. block "Create "gmax_merged_1.5.RData"").]
	  SI.h100.vec <- (h100.vec - hb0 - hb1 * log(x = age.vec) - hb2 * ((log(x = age.vec)) ^ 2)) / (hb3 + hb4 * log(x = age.vec))
	  ## Calculate difference between SI.h100 value of current yield class and SI.h100 value of yield class 1.
	  SI.h100.diff.EKL.I.vec <- round(x = SI.h100.vec - SI.h100.yield.class.1, digits = 1)
	  ## Append the vectors for the current yield class to "test.df". 
	  test.df <- rbind(test.df,
		         data.frame("age" = age.vec,
				"yield.class" = as.factor(x = cur.yield.class),
				"h100" = h100.vec,
				"h100.EKL.I" = h100.EKL.I.vec,
				"SI.h100" = SI.h100.vec,
				"SI.h100.diff.EKL.I" = SI.h100.diff.EKL.I.vec))
        }
        ## Plot observations ##
    #######################
        ## Initiate legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        legend.lwd <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
        ## Generate a color palette of the same length as "SI.h100.sequence".
        cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
        ## Define y-axis labels and plot margins, depending on which species (and thus which plot) we are at.
        if (cur.species.name == "beech") {
	  y.lab <- expression(italic("G")*" ["*m^2*" ha"^-1*"]")
	  left.margin <- 3.25
	  right.margin <- 0
        } else {
	  y.lab <- ""
	  left.margin <- 2
	  right.margin <- 1
        }
        ## Set plot margins.
        par("mar" = c(3, left.margin, 2, right.margin))
        ## Create empty plot.
        plot(x = cur.input.data[["alt"]],
	   type = "n",
	   xlim = kXLim,
	   ylim = kYLim,
	   xlab = "Alter [a]",
	   ylab = y.lab,
	   main = cur.species.name.capitalized,
	   mgp = kPlotMgp,
	   xaxs = "i",
	   yaxs = "i",
	   panel.first = abline(v = seq(from = kXLim[1],
				  to = kXLim[2],
				  by = 10),
			    h  = seq(from = kYLim[1],
				   to = kYLim[2],
				   by = 10),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Loop over all evdids.
        for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	  ## Create subset of "cur.input.data", based on current edvid.
	  edvid.subset <- subset(x = cur.input.data,
			     subset = edvid == cur.edvid)
	  ## Add lines for observations belonging to current edvid.
	  lines(x =edvid.subset[["alt"]],
	        y = edvid.subset[["gha"]],
	        lwd = kLineWidth,
	        lty = kLineType)
        }
        ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
        for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	  ## Create subset of "cur.input.data", based on current edvid.
	  edvid.subset <- subset(x = cur.input.data,
			     subset = edvid == cur.edvid)
	  ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	  SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				         table = SI.h100.sequence)
	  ## Add points to plot.
	  points(x = edvid.subset[["alt"]],
	         y = edvid.subset[["gha"]],
	         col = cur.species.color.palette[SI.h100.rounded.color.index],
	         pch = kPointCharacter)
        }
        ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
        SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						      digits = 1),
					      table = SI.h100.sequence)
        ## Update legend components.
        ## legend.legend <- c(legend.legend,
		       ## paste0("Beobachtung EKL ",
			    ## SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        ## legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
        ## legend.pch <- c(legend.pch, rep(x = kPointCharacter, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        ## legend.lty <- c(legend.lty, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        ## legend.lwd <- c(legend.lwd, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        ## Add model predictions to plot ##
        ###################################
        ## Get test data for current species.
        new.data <- test.df
        ## Restrict "new.data" to the columns of the independent variables of the current model.
        new.data <- subset(x = new.data,
		       select = all.vars(cur.formula)[-1])
        ## Calculate model predictions.
        new.data[["gha.predictions"]] <- predict(object = cur.model,
				         newdata = new.data,
				         what = "mu",
				         type = "response")
        ## Reattach columns "age", "h100", and "yield.class" to "new.data".
        new.data[["age"]] <- na.omit(object = test.df)[["age"]]
        new.data[["h100"]] <- na.omit(object = test.df)[["h100"]]
        new.data[["yield.class"]] <- na.omit(object = test.df)[["yield.class"]]
        ## Add lines to plot per yield class.
        all.cols <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
        for (cur.yield.class.index in seq_len(length.out = length(x = levels(x = new.data[["yield.class"]])))) {
	  yield.class.name <- levels(x = new.data[["yield.class"]])[cur.yield.class.index]
	  line.col <- all.cols[cur.yield.class.index]
	  lines(x = new.data[["age"]][new.data[["yield.class"]] == yield.class.name],
	        y = new.data[["gha.predictions"]][new.data[["yield.class"]] == yield.class.name],
	        col = line.col,
	        lty = kLineType,
	        lwd = kLineWidth)
        }
        ## Add box around plot.
        box(bty = "o")
        ## Update legend components.
        legend.legend <- c(legend.legend,
			 paste0("EKL ",
			        SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
	  legend.col <- c(legend.col,
		        cur.species.color.palette[SI.h100.yield.class.values.color.index])
	  legend.pch <- c(legend.pch,
		        rep(x = kPointCharacter,
			  times = length(x = SI.h100.yield.class.values[["yield.class"]])))
	  legend.lty <- c(legend.lty,
		        rep(x = kLineType,
			  times = length(x = SI.h100.yield.class.values[["yield.class"]])))
	  legend.lwd <- c(legend.lwd,
		        rep(x = kLineWidth,
			  times = length(x = SI.h100.yield.class.values[["yield.class"]])))
        ## Set position of legend, depending on species.
        if (cur.species.name == "beech") {
	  legend.x <- "topleft"
        }
        if (cur.species.name == "spruce") {
	  legend.x <- "bottomright"
        }
        ## Add legend.
        legend(x = legend.x,
	     ncol = kLegendNcol,
	     legend = legend.legend,
	     col = legend.col,
	     pch = legend.pch,
	     lty = legend.lty,
	     lwd = legend.lwd,
	     bg = kLegendBg)
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.                                   
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* TopHeightBasalAreaObservationsGAMLSSUnconstrainedPredictions.pdf
  #+NAME: TopHeightBasalAreaObservationsGAMLSSUnconstrainedPredictions.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArPresentationRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Presentation/Modelling.tex
    ## Plotting preamble ##
    #######################
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:2,
		      nrow = 1,
		      ncol = 2)
    kLegendNcol <- 2
    kXLim <- c(0, 50)
    kYLim <- c(0, 85)
    ## Create file name.
    kFilename <-paste0(kGraphicsSubdir,
		   "TopHeightBasalAreaObservationsGAMLSSUnconstrainedPredictions.pdf")
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Modelling preamble ##
    ########################
    library(package = "gamlss")
    ## Turn off graphics device.
    graphics.off()
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = kFilename,
        width = kPdfWidthSlide / 2,
        height = kPdfHeightSlide / 2 * 0.9,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Loop over species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get translated version of current species name.
        if (cur.species.name == "beech") {
	  cur.species.name.capitalized <- "Buche"
        }
        if (cur.species.name == "spruce") {
	  cur.species.name.capitalized <- "Fichte"
        }
        ## Fit model ##
    ###############
        ## Get unconstrained model formula for current species.
        cur.formula <- kUnconstrainedFormulas[[cur.species.name]]
        ## Get input data frame for current species.
        cur.input.data <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Subset input data frame to the variables mentioned in the model formula.
        cur.input.data.col.subset <- cur.input.data[, all.vars(expr = cur.formula)]
        ## Remove missing values from "cur.input.data.col.subset".
        cur.input.data.col.subset.na.omitted <- na.omit(object = cur.input.data.col.subset)
        ## Fit model.
        cur.model <- gamlss::gamlss(formula = cur.formula,
			      sigma.formula = "gha ~ 1",
			      nu.formula = "gha ~ 1",
			      tau.formula = "gha ~ 1",
			      family = gamlss.dist::BCCGo(),
			      data = cur.input.data.col.subset.na.omitted,
			      method = RS(1000))
        ## Generate test data ##
    ########################
        ## The test data should cover the same yield class range as the training data.
        ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
        SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				         "SI.h100" = NA)
        ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
        if (cur.species.name == "beech") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
        }
        if (cur.species.name == "spruce") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
        }
        ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
        for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	  SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	  SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
        }
        ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
        SI.h100.min <- min(cur.input.data[["SI.h100"]],
		       na.rm = TRUE)
        SI.h100.max <- max(cur.input.data[["SI.h100"]],
		       na.rm = TRUE)
        index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
        index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
        ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
        SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				  to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				  by = 0.1),
			    digits = 1)
        ## Initiate data frame in which to store test data.  The data frame will contain the following columns:
        ## - age
        ## - yield.class
        ## - h100
        ## - h100.EKL.I
        ## - SI.h100
        ## - SI.h100.diff.EKL.I
        test.df <- data.frame(NULL)
        ## Assign species-specific coefficients of Nagel function (taken from Nagel (1999), tab. 4).
        if (cur.species.name == "beech") {
	  hb0 <- -75.659
	  hb1 <- 23.192
	  hb2 <- -1.468
	  hb3 <- 0
	  hb4 <- 0.2152
        }
        if (cur.species.name == "spruce") {
	  hb0 <- -49.872
	  hb1 <- 7.3309
	  hb2 <- 0.77338
	  hb3 <- 0.52684
	  hb4 <- 0.10542
        }
        ## Create age vector (required by all yield classes, so we make this assignment before starting the loop).
        age.vec <- seq(from = 10,
		   to = 160,
		   by = 1)
        ## Get SI.h100 value for yield class 1 (required by all yield classes, so we make this assignment before starting the loop).
        SI.h100.yield.class.1 <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == 1, "SI.h100"]
        ## Calculate h100 for yield class 1 using Nagel (1999), eq. (13) (required by all yield classes, so we make this assignment before starting the loop).
        h100.EKL.I.vec <- SI.h100.yield.class.1 * (hb3 + hb4 * log(x = age.vec)) + hb0 + hb1 * log(x = age.vec) + hb2 * (log(x = age.vec)) ^ 2
        ## Loop over all yield classes required to cover the training data (i.e., the range from worst to best yield class needed).
        for (cur.yield.class in SI.h100.yield.class.values[index.worst.yield.class.needed:index.best.yield.class.needed, "yield.class"]) {
	  ## Get SI.h100 value for current yield class from "SI.h100.yield.class.values"
	  SI.h100.cur.yield.class <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == cur.yield.class, "SI.h100"]
	  ## Calculate h100 for the current yield class using Nagel (1999), eq. (13).
	  h100.vec <- SI.h100.cur.yield.class * (hb3 + hb4 * log(x = age.vec)) + hb0 + hb1 * log(x = age.vec) + hb2 * (log(x = age.vec)) ^ 2
	  ## Calculate SI.h100 for the current yield class using Nagel (1999), eq. (13). [This procedure is a bit redundant, since it simply results in the "SI.h100.cur.yield.class" value defined above. I nevertheless opt for it, in order to make sure that the test data for sensitivity analysis is created in exactly the same way as the original data for model fitting was (cp. block "Create "gmax_merged_1.5.RData"").]
	  SI.h100.vec <- (h100.vec - hb0 - hb1 * log(x = age.vec) - hb2 * ((log(x = age.vec)) ^ 2)) / (hb3 + hb4 * log(x = age.vec))
	  ## Calculate difference between SI.h100 value of current yield class and SI.h100 value of yield class 1.
	  SI.h100.diff.EKL.I.vec <- round(x = SI.h100.vec - SI.h100.yield.class.1, digits = 1)
	  ## Append the vectors for the current yield class to "test.df". 
	  test.df <- rbind(test.df,
		         data.frame("age" = age.vec,
				"yield.class" = as.factor(x = cur.yield.class),
				"h100" = h100.vec,
				"h100.EKL.I" = h100.EKL.I.vec,
				"SI.h100" = SI.h100.vec,
				"SI.h100.diff.EKL.I" = SI.h100.diff.EKL.I.vec))
        }
        ## Plot observations ##
    #######################    
        ## Initiate legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        legend.lwd <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
        ## Generate a color palette of the same length as "SI.h100.sequence".
        cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
        ## Define y-axis labels and plot margins, depending on which species (and thus which plot) we are at.
        if (cur.species.name == "beech") {
	  y.lab <- expression(italic("G")*" ["*m^2*" ha"^-1*"]")
	  left.margin <- 3.25
	  right.margin <- 0
        } else {
	  y.lab <- ""
	  left.margin <- 2
	  right.margin <- 1
        }
        ## Set plot margins.
        par("mar" = c(3, left.margin, 2, right.margin))
        ## Create empty plot.
        plot(x = cur.input.data[["h100"]],
	   type = "n",
	   xlim = kXLim,
	   ylim = kYLim,
	   xlab = expression(italic("h")["100"]*" [m]"),
	   ylab = y.lab,
	   main = cur.species.name.capitalized,
	   mgp = kPlotMgp,
	   xaxs = "i",
	   yaxs = "i",
	   panel.first = abline(v = seq(from = kXLim[1],
				  to = kXLim[2],
				  by = 10),
			    h  = seq(from = kYLim[1],
				   to = kYLim[2],
				   by = 10),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Loop over all evdids.
        for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	  ## Create subset of "cur.input.data", based on current edvid.
	  edvid.subset <- subset(x = cur.input.data,
			     subset = edvid == cur.edvid)
	  ## Add lines for observations belonging to current edvid.
	  lines(x =edvid.subset[["h100"]],
	        y = edvid.subset[["gha"]],
	        lwd = kLineWidth,
	        lty = kLineType)
        }
        ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
        for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	  ## Create subset of "cur.input.data", based on current edvid.
	  edvid.subset <- subset(x = cur.input.data,
			     subset = edvid == cur.edvid)
	  ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	  SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				         table = SI.h100.sequence)
	  ## Add points to plot.
	  points(x = edvid.subset[["h100"]],
	         y = edvid.subset[["gha"]],
	         col = cur.species.color.palette[SI.h100.rounded.color.index],
	         pch = kPointCharacter)
        }
        ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
        SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						      digits = 1),
					      table = SI.h100.sequence)
        ## Update legend components.
        ## legend.legend <- c(legend.legend,
        ## paste0("Beobachtung EKL ",
        ## SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        ## legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
        ## legend.pch <- c(legend.pch, rep(x = kPointCharacter, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        ## legend.lty <- c(legend.lty, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        ## legend.lwd <- c(legend.lwd, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        ## Add model predictions to plot ##
    ###################################
        ## Get test data for current species.
        new.data <- test.df
        ## Restrict "new.data" to the columns of the independent variables of the current model.
        new.data <- subset(x = new.data,
		       select = all.vars(cur.formula)[-1])
        ## Calculate model predictions.
        new.data[["gha.predictions"]] <- predict(object = cur.model,
				         newdata = new.data,
				         what = "mu",
				         type = "response")
        ## Reattach columns "age", "h100", and "yield.class" to "new.data".
        new.data[["age"]] <- na.omit(object = test.df)[["age"]]
        new.data[["h100"]] <- na.omit(object = test.df)[["h100"]]
        new.data[["yield.class"]] <- na.omit(object = test.df)[["yield.class"]]
        ## Add lines to plot per yield class.
        all.cols <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
        for (cur.yield.class.index in seq_len(length.out = length(x = levels(x = new.data[["yield.class"]])))) {
	  yield.class.name <- levels(x = new.data[["yield.class"]])[cur.yield.class.index]
	  line.col <- all.cols[cur.yield.class.index]
	  lines(x = new.data[["h100"]][new.data[["yield.class"]] == yield.class.name],
	        y = new.data[["gha.predictions"]][new.data[["yield.class"]] == yield.class.name],
	        col = line.col,
	        lty = kLineType,
	        lwd = kLineWidth)
	  ## Update legend components.
	  ## legend.legend <- c(legend.legend,
	  ## paste0("Vorhersage EKL ",
	  ## yield.class.name))
	  ## legend.pch <- c(legend.pch, NA)
	  ## legend.lty <- c(legend.lty, kLineType)
	  ## legend.lwd <- c(legend.lwd, kLineWidth)
	  ## legend.col <- c(legend.col, line.col)
        }
        ## Add box around plot.
        box(bty = "o")
        ## Update legend components.
        legend.legend <- c(legend.legend,
		       paste0("EKL ",
			    SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        legend.col <- c(legend.col,
		    cur.species.color.palette[SI.h100.yield.class.values.color.index])
        legend.pch <- c(legend.pch,
		    rep(x = kPointCharacter,
		        times = length(x = SI.h100.yield.class.values[["yield.class"]])))
        legend.lty <- c(legend.lty,
		    rep(x = kLineType,
		        times = length(x = SI.h100.yield.class.values[["yield.class"]])))
        legend.lwd <- c(legend.lwd,
		    rep(x = kLineWidth,
		        times = length(x = SI.h100.yield.class.values[["yield.class"]])))
        ## Set position of legend, depending on species.
        if (cur.species.name == "beech") {
	  legend.x <- "topleft"
        }
        if (cur.species.name == "spruce") {
	  legend.x <- "bottomright"
        }
        ## Add legend.
        legend(x = legend.x,
	     ncol = kLegendNcol,
	     legend = legend.legend,
	     col = legend.col,
	     pch = legend.pch,
	     lty = legend.lty,
	     lwd = legend.lwd,
	     bg = kLegendBg)
        ## Reset legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        legend.lwd <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.                                   
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* StandAgeBasalAreaObservationsGAMLSSConstrainedPredictions.pdf
  #+NAME: StandAgeBasalAreaObservationsGAMLSSConstrainedPredictions.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArPresentationRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Presentation/Modelling.tex
    ## Plotting preamble ##
    #######################
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:2,
		      nrow = 1,
		      ncol = 2)
    kLegendNcol <- 2
    kXLim <- c(0, 160)
    kYLim <- c(0, 85)
    ## Create file name.
    kFilename <-paste0(kGraphicsSubdir,
		   "StandAgeBasalAreaObservationsGAMLSSConstrainedPredictions.pdf")
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Modelling preamble ##
    ########################
    library(package = "gamlss")
    ## Define segmented functions.
    rhs <- function (x, c) {
        return(ifelse(test = x > c,
		  yes = x-c,
		  no = 0))
    }
    lhs <- function (x, c) {
        return(ifelse(test = x <= c,
		  yes = c-x,
		  no = 0))
    }
    ## Turn off graphics device.
    graphics.off()
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = kFilename,
        width = kPdfWidthSlide / 2,
        height = kPdfHeightSlide / 2 * 0.9,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Loop over species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get translated version of current species name.
        if (cur.species.name == "beech") {
	  cur.species.name.capitalized <- "Buche"
        }
        if (cur.species.name == "spruce") {
	  cur.species.name.capitalized <- "Fichte"
        }
        ## Fit model ##
    ###############
        ## Get constrained model formula for current species.
        cur.formula <- kConstrainedFormulas[[cur.species.name]]
        ## Get input data frame for current species.
        cur.input.data <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Subset input data frame to the variables mentioned in the model formula.
        cur.input.data.col.subset <- cur.input.data[, all.vars(expr = cur.formula)]
        ## Remove missing values from "cur.input.data.col.subset".
        cur.input.data.col.subset.na.omitted <- na.omit(object = cur.input.data.col.subset)
        ## Fit model.
        cur.model <- gamlss::gamlss(formula = cur.formula,
			      sigma.formula = "gha ~ 1",
			      nu.formula = "gha ~ 1",
			      tau.formula = "gha ~ 1",
			      family = gamlss.dist::BCCGo(),
			      data = cur.input.data.col.subset.na.omitted,
			      method = RS(1000))
	  ## Generate test data ##
    ########################
        ## The test data should cover the same yield class range as the training data.
        ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
        SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				         "SI.h100" = NA)
        ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
        if (cur.species.name == "beech") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
        }
        if (cur.species.name == "spruce") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
        }
        ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
        for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	  SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	  SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
        }
        ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
        SI.h100.min <- min(cur.input.data[["SI.h100"]],
		       na.rm = TRUE)
        SI.h100.max <- max(cur.input.data[["SI.h100"]],
		       na.rm = TRUE)
        index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
        index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
        ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
        SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				  to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				  by = 0.1),
			    digits = 1)
        ## Initiate data frame in which to store test data.  The data frame will contain the following columns:
        ## - age
        ## - yield.class
        ## - h100
        ## - h100.EKL.I
        ## - SI.h100
        ## - SI.h100.diff.EKL.I
        test.df <- data.frame(NULL)
        ## Assign species-specific coefficients of Nagel function (taken from Nagel (1999), tab. 4).
        if (cur.species.name == "beech") {
	  hb0 <- -75.659
	  hb1 <- 23.192
	  hb2 <- -1.468
	  hb3 <- 0
	  hb4 <- 0.2152
        }
        if (cur.species.name == "spruce") {
	  hb0 <- -49.872
	  hb1 <- 7.3309
	  hb2 <- 0.77338
	  hb3 <- 0.52684
	  hb4 <- 0.10542
        }
        ## Create age vector (required by all yield classes, so we make this assignment before starting the loop).
        age.vec <- seq(from = 10,
		   to = 160,
		   by = 1)
        ## Get SI.h100 value for yield class 1 (required by all yield classes, so we make this assignment before starting the loop).
        SI.h100.yield.class.1 <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == 1, "SI.h100"]
        ## Calculate h100 for yield class 1 using Nagel (1999), eq. (13) (required by all yield classes, so we make this assignment before starting the loop).
        h100.EKL.I.vec <- SI.h100.yield.class.1 * (hb3 + hb4 * log(x = age.vec)) + hb0 + hb1 * log(x = age.vec) + hb2 * (log(x = age.vec)) ^ 2
        ## Loop over all yield classes required to cover the training data (i.e., the range from worst to best yield class needed).
        for (cur.yield.class in SI.h100.yield.class.values[index.worst.yield.class.needed:index.best.yield.class.needed, "yield.class"]) {
	  ## Get SI.h100 value for current yield class from "SI.h100.yield.class.values"
	  SI.h100.cur.yield.class <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == cur.yield.class, "SI.h100"]
	  ## Calculate h100 for the current yield class using Nagel (1999), eq. (13).
	  h100.vec <- SI.h100.cur.yield.class * (hb3 + hb4 * log(x = age.vec)) + hb0 + hb1 * log(x = age.vec) + hb2 * (log(x = age.vec)) ^ 2
	  ## Calculate SI.h100 for the current yield class using Nagel (1999), eq. (13). [This procedure is a bit redundant, since it simply results in the "SI.h100.cur.yield.class" value defined above. I nevertheless opt for it, in order to make sure that the test data for sensitivity analysis is created in exactly the same way as the original data for model fitting was (cp. block "Create "gmax_merged_1.5.RData"").]
	  SI.h100.vec <- (h100.vec - hb0 - hb1 * log(x = age.vec) - hb2 * ((log(x = age.vec)) ^ 2)) / (hb3 + hb4 * log(x = age.vec))
	  ## Calculate difference between SI.h100 value of current yield class and SI.h100 value of yield class 1.
	  SI.h100.diff.EKL.I.vec <- round(x = SI.h100.vec - SI.h100.yield.class.1, digits = 1)
	  ## Append the vectors for the current yield class to "test.df". 
	  test.df <- rbind(test.df,
		         data.frame("age" = age.vec,
				"yield.class" = as.factor(x = cur.yield.class),
				"h100" = h100.vec,
				"h100.EKL.I" = h100.EKL.I.vec,
				"SI.h100" = SI.h100.vec,
				"SI.h100.diff.EKL.I" = SI.h100.diff.EKL.I.vec))
        }
        ## Plot observations ##
    #######################
        ## Initiate legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        legend.lwd <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
        ## Generate a color palette of the same length as "SI.h100.sequence".
        cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
        ## Define y-axis labels and plot margins, depending on which species (and thus which plot) we are at.
        if (cur.species.name == "beech") {
	  y.lab <- expression(italic("G")*" ["*m^2*" ha"^-1*"]")
	  left.margin <- 3.25
	  right.margin <- 0
        } else {
	  y.lab <- ""
	  left.margin <- 2
	  right.margin <- 1
        }
        ## Set plot margins.
        par("mar" = c(3, left.margin, 2, right.margin))
        ## Create empty plot.
        plot(x = cur.input.data[["alt"]],
	   type = "n",
	   xlim = kXLim,
	   ylim = kYLim,
	   xlab = "Alter [a]",
	   ylab = y.lab,
	   main = cur.species.name.capitalized,
	   mgp = kPlotMgp,
	   xaxs = "i",
	   yaxs = "i",
	   panel.first = abline(v = seq(from = kXLim[1],
				  to = kXLim[2],
				  by = 10),
			    h  = seq(from = kYLim[1],
				   to = kYLim[2],
				   by = 10),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Loop over all evdids.
        for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	  ## Create subset of "cur.input.data", based on current edvid.
	  edvid.subset <- subset(x = cur.input.data,
			     subset = edvid == cur.edvid)
	  ## Add lines for observations belonging to current edvid.
	  lines(x =edvid.subset[["alt"]],
	        y = edvid.subset[["gha"]],
	        lwd = kLineWidth,
	        lty = kLineType)
        }
        ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
        for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	  ## Create subset of "cur.input.data", based on current edvid.
	  edvid.subset <- subset(x = cur.input.data,
			     subset = edvid == cur.edvid)
	  ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	  SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				         table = SI.h100.sequence)
	  ## Add points to plot.
	  points(x = edvid.subset[["alt"]],
	         y = edvid.subset[["gha"]],
	         col = cur.species.color.palette[SI.h100.rounded.color.index],
	         pch = kPointCharacter)
        }
        ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
        SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						      digits = 1),
					      table = SI.h100.sequence)
        ## Update legend components.
        ## legend.legend <- c(legend.legend,
		       ## paste0("Beobachtung EKL ",
			    ## SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        ## legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
        ## legend.pch <- c(legend.pch, rep(x = kPointCharacter, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        ## legend.lty <- c(legend.lty, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        ## legend.lwd <- c(legend.lwd, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        ## Add model predictions to plot ##
        ###################################
        ## Get test data for current species.
        new.data <- test.df
        ## Restrict "new.data" to the columns of the independent variables of the current model.
        new.data <- subset(x = new.data,
		       select = all.vars(cur.formula)[-1])
        ## Calculate model predictions.
        new.data[["gha.predictions"]] <- predict(object = cur.model,
				         newdata = new.data,
				         what = "mu",
				         type = "response")
        ## Reattach columns "age", "h100", and "yield.class" to "new.data".
        new.data[["age"]] <- na.omit(object = test.df)[["age"]]
        new.data[["h100"]] <- na.omit(object = test.df)[["h100"]]
        new.data[["yield.class"]] <- na.omit(object = test.df)[["yield.class"]]
        ## Add lines to plot per yield class.
        all.cols <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
        for (cur.yield.class.index in seq_len(length.out = length(x = levels(x = new.data[["yield.class"]])))) {
	  yield.class.name <- levels(x = new.data[["yield.class"]])[cur.yield.class.index]
	  line.col <- all.cols[cur.yield.class.index]
	  lines(x = new.data[["age"]][new.data[["yield.class"]] == yield.class.name],
	        y = new.data[["gha.predictions"]][new.data[["yield.class"]] == yield.class.name],
	        col = line.col,
	        lty = kLineType,
	        lwd = kLineWidth)
        }
        ## Add box around plot.
        box(bty = "o")
        ## Update legend components.
        legend.legend <- c(legend.legend,
			 paste0("EKL ",
			        SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
	  legend.col <- c(legend.col,
		        cur.species.color.palette[SI.h100.yield.class.values.color.index])
	  legend.pch <- c(legend.pch,
		        rep(x = kPointCharacter,
			  times = length(x = SI.h100.yield.class.values[["yield.class"]])))
	  legend.lty <- c(legend.lty,
		        rep(x = kLineType,
			  times = length(x = SI.h100.yield.class.values[["yield.class"]])))
	  legend.lwd <- c(legend.lwd,
		        rep(x = kLineWidth,
			  times = length(x = SI.h100.yield.class.values[["yield.class"]])))
        ## Set position of legend, depending on species.
        if (cur.species.name == "beech") {
	  legend.x <- "topleft"
        }
        if (cur.species.name == "spruce") {
	  legend.x <- "bottomright"
        }
        ## Add legend.
        legend(x = legend.x,
	     ncol = kLegendNcol,
	     legend = legend.legend,
	     col = legend.col,
	     pch = legend.pch,
	     lty = legend.lty,
	     lwd = legend.lwd,
	     bg = kLegendBg)
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.                                   
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* TopHeightBasalAreaObservationsGAMLSSConstrainedPredictions.pdf
  #+NAME: TopHeightBasalAreaObservationsGAMLSSConstrainedPredictions.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArPresentationRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Presentation/Modelling.tex
    ## Plotting preamble ##
    #######################
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- matrix(data = 1:2,
		      nrow = 1,
		      ncol = 2)
    kLegendNcol <- 2
    kXLim <- c(0, 50)
    kYLim <- c(0, 85)
    ## Create file name.
    kFilename <-paste0(kGraphicsSubdir,
		   "TopHeightBasalAreaObservationsGAMLSSConstrainedPredictions.pdf")
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Modelling preamble ##
    ########################
    library(package = "gamlss")
    ## Define segmented functions.
    rhs <- function (x, c) {
        return(ifelse(test = x > c,
		  yes = x-c,
		  no = 0))
    }
    lhs <- function (x, c) {
        return(ifelse(test = x <= c,
		  yes = c-x,
		  no = 0))
    }
    ## Turn off graphics device.
    graphics.off()
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = kFilename,
        width = kPdfWidthSlide / 2,
        height = kPdfHeightSlide / 2 * 0.9,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Loop over species names.
    for (cur.species.name in kSpeciesNames) {
        ## Get translated version of current species name.
        if (cur.species.name == "beech") {
	  cur.species.name.capitalized <- "Buche"
        }
        if (cur.species.name == "spruce") {
	  cur.species.name.capitalized <- "Fichte"
        }
        ## Fit model ##
    ###############
        ## Get constrained model formula for current species.
        cur.formula <- kConstrainedFormulas[[cur.species.name]]
        ## Get input data frame for current species.
        cur.input.data <- get(x = paste0("bart.", cur.species.name, ".clean.1.8"))
        ## Subset input data frame to the variables mentioned in the model formula.
        cur.input.data.col.subset <- cur.input.data[, all.vars(expr = cur.formula)]
        ## Remove missing values from "cur.input.data.col.subset".
        cur.input.data.col.subset.na.omitted <- na.omit(object = cur.input.data.col.subset)
        ## Fit model.
        cur.model <- gamlss::gamlss(formula = cur.formula,
			      sigma.formula = "gha ~ 1",
			      nu.formula = "gha ~ 1",
			      tau.formula = "gha ~ 1",
			      family = gamlss.dist::BCCGo(),
			      data = cur.input.data.col.subset.na.omitted,
			      method = RS(1000))
        ## Generate test data ##
    ########################
        ## The test data should cover the same yield class range as the training data.
        ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
        SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				         "SI.h100" = NA)
        ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
        if (cur.species.name == "beech") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
        }
        if (cur.species.name == "spruce") {
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 23.5
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 27.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 31.2
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 35.1
        }
        ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
        for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
	  SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
	  SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
	  SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
        }
        ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
        SI.h100.min <- min(cur.input.data[["SI.h100"]],
		       na.rm = TRUE)
        SI.h100.max <- max(cur.input.data[["SI.h100"]],
		       na.rm = TRUE)
        index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
        index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
        ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
        SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
				  to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
				  by = 0.1),
			    digits = 1)
        ## Initiate data frame in which to store test data.  The data frame will contain the following columns:
        ## - age
        ## - yield.class
        ## - h100
        ## - h100.EKL.I
        ## - SI.h100
        ## - SI.h100.diff.EKL.I
        test.df <- data.frame(NULL)
        ## Assign species-specific coefficients of Nagel function (taken from Nagel (1999), tab. 4).
        if (cur.species.name == "beech") {
	  hb0 <- -75.659
	  hb1 <- 23.192
	  hb2 <- -1.468
	  hb3 <- 0
	  hb4 <- 0.2152
        }
        if (cur.species.name == "spruce") {
	  hb0 <- -49.872
	  hb1 <- 7.3309
	  hb2 <- 0.77338
	  hb3 <- 0.52684
	  hb4 <- 0.10542
        }
        ## Create age vector (required by all yield classes, so we make this assignment before starting the loop).
        age.vec <- seq(from = 10,
		   to = 160,
		   by = 1)
        ## Get SI.h100 value for yield class 1 (required by all yield classes, so we make this assignment before starting the loop).
        SI.h100.yield.class.1 <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == 1, "SI.h100"]
        ## Calculate h100 for yield class 1 using Nagel (1999), eq. (13) (required by all yield classes, so we make this assignment before starting the loop).
        h100.EKL.I.vec <- SI.h100.yield.class.1 * (hb3 + hb4 * log(x = age.vec)) + hb0 + hb1 * log(x = age.vec) + hb2 * (log(x = age.vec)) ^ 2
        ## Loop over all yield classes required to cover the training data (i.e., the range from worst to best yield class needed).
        for (cur.yield.class in SI.h100.yield.class.values[index.worst.yield.class.needed:index.best.yield.class.needed, "yield.class"]) {
	  ## Get SI.h100 value for current yield class from "SI.h100.yield.class.values"
	  SI.h100.cur.yield.class <- SI.h100.yield.class.values[SI.h100.yield.class.values[["yield.class"]] == cur.yield.class, "SI.h100"]
	  ## Calculate h100 for the current yield class using Nagel (1999), eq. (13).
	  h100.vec <- SI.h100.cur.yield.class * (hb3 + hb4 * log(x = age.vec)) + hb0 + hb1 * log(x = age.vec) + hb2 * (log(x = age.vec)) ^ 2
	  ## Calculate SI.h100 for the current yield class using Nagel (1999), eq. (13). [This procedure is a bit redundant, since it simply results in the "SI.h100.cur.yield.class" value defined above. I nevertheless opt for it, in order to make sure that the test data for sensitivity analysis is created in exactly the same way as the original data for model fitting was (cp. block "Create "gmax_merged_1.5.RData"").]
	  SI.h100.vec <- (h100.vec - hb0 - hb1 * log(x = age.vec) - hb2 * ((log(x = age.vec)) ^ 2)) / (hb3 + hb4 * log(x = age.vec))
	  ## Calculate difference between SI.h100 value of current yield class and SI.h100 value of yield class 1.
	  SI.h100.diff.EKL.I.vec <- round(x = SI.h100.vec - SI.h100.yield.class.1, digits = 1)
	  ## Append the vectors for the current yield class to "test.df". 
	  test.df <- rbind(test.df,
		         data.frame("age" = age.vec,
				"yield.class" = as.factor(x = cur.yield.class),
				"h100" = h100.vec,
				"h100.EKL.I" = h100.EKL.I.vec,
				"SI.h100" = SI.h100.vec,
				"SI.h100.diff.EKL.I" = SI.h100.diff.EKL.I.vec))
        }
        ## Plot observations ##
    #######################    
        ## Initiate legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        legend.lwd <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
        ## Generate a color palette of the same length as "SI.h100.sequence".
        cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
        ## Define y-axis labels and plot margins, depending on which species (and thus which plot) we are at.
        if (cur.species.name == "beech") {
	  y.lab <- expression(italic("G")*" ["*m^2*" ha"^-1*"]")
	  left.margin <- 3.25
	  right.margin <- 0
        } else {
	  y.lab <- ""
	  left.margin <- 2
	  right.margin <- 1
        }
        ## Set plot margins.
        par("mar" = c(3, left.margin, 2, right.margin))
        ## Create empty plot.
        plot(x = cur.input.data[["h100"]],
	   type = "n",
	   xlim = kXLim,
	   ylim = kYLim,
	   xlab = expression(italic("h")["100"]*" [m]"),
	   ylab = y.lab,
	   main = cur.species.name.capitalized,
	   mgp = kPlotMgp,
	   xaxs = "i",
	   yaxs = "i",
	   panel.first = abline(v = seq(from = kXLim[1],
				  to = kXLim[2],
				  by = 10),
			    h  = seq(from = kYLim[1],
				   to = kYLim[2],
				   by = 10),
			    lty = kGridLineType,
			    lwd = kGridLineWidth,
			    col = kGridLineCol))
        ## Loop over all evdids.
        for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	  ## Create subset of "cur.input.data", based on current edvid.
	  edvid.subset <- subset(x = cur.input.data,
			     subset = edvid == cur.edvid)
	  ## Add lines for observations belonging to current edvid.
	  lines(x =edvid.subset[["h100"]],
	        y = edvid.subset[["gha"]],
	        lwd = kLineWidth,
	        lty = kLineType)
        }
        ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
        for (cur.edvid in levels(x = cur.input.data[["edvid"]])) {
	  ## Create subset of "cur.input.data", based on current edvid.
	  edvid.subset <- subset(x = cur.input.data,
			     subset = edvid == cur.edvid)
	  ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
	  SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				         table = SI.h100.sequence)
	  ## Add points to plot.
	  points(x = edvid.subset[["h100"]],
	         y = edvid.subset[["gha"]],
	         col = cur.species.color.palette[SI.h100.rounded.color.index],
	         pch = kPointCharacter)
        }
        ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
        SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						      digits = 1),
					      table = SI.h100.sequence)
        ## Update legend components.
        ## legend.legend <- c(legend.legend,
        ## paste0("Beobachtung EKL ",
        ## SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        ## legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
        ## legend.pch <- c(legend.pch, rep(x = kPointCharacter, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        ## legend.lty <- c(legend.lty, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        ## legend.lwd <- c(legend.lwd, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
        ## Add model predictions to plot ##
    ###################################
        ## Get test data for current species.
        new.data <- test.df
        ## Restrict "new.data" to the columns of the independent variables of the current model.
        new.data <- subset(x = new.data,
		       select = all.vars(cur.formula)[-1])
        ## Calculate model predictions.
        new.data[["gha.predictions"]] <- predict(object = cur.model,
				         newdata = new.data,
				         what = "mu",
				         type = "response")
        ## Reattach columns "age", "h100", and "yield.class" to "new.data".
        new.data[["age"]] <- na.omit(object = test.df)[["age"]]
        new.data[["h100"]] <- na.omit(object = test.df)[["h100"]]
        new.data[["yield.class"]] <- na.omit(object = test.df)[["yield.class"]]
        ## Add lines to plot per yield class.
        all.cols <- cur.species.color.palette[SI.h100.yield.class.values.color.index]
        for (cur.yield.class.index in seq_len(length.out = length(x = levels(x = new.data[["yield.class"]])))) {
	  yield.class.name <- levels(x = new.data[["yield.class"]])[cur.yield.class.index]
	  line.col <- all.cols[cur.yield.class.index]
	  lines(x = new.data[["h100"]][new.data[["yield.class"]] == yield.class.name],
	        y = new.data[["gha.predictions"]][new.data[["yield.class"]] == yield.class.name],
	        col = line.col,
	        lty = kLineType,
	        lwd = kLineWidth)
	  ## Update legend components.
	  ## legend.legend <- c(legend.legend,
	  ## paste0("Vorhersage EKL ",
	  ## yield.class.name))
	  ## legend.pch <- c(legend.pch, NA)
	  ## legend.lty <- c(legend.lty, kLineType)
	  ## legend.lwd <- c(legend.lwd, kLineWidth)
	  ## legend.col <- c(legend.col, line.col)
        }
        ## Add box around plot.
        box(bty = "o")
        ## Update legend components.
        legend.legend <- c(legend.legend,
		       paste0("EKL ",
			    SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
        legend.col <- c(legend.col,
		    cur.species.color.palette[SI.h100.yield.class.values.color.index])
        legend.pch <- c(legend.pch,
		    rep(x = kPointCharacter,
		        times = length(x = SI.h100.yield.class.values[["yield.class"]])))
        legend.lty <- c(legend.lty,
		    rep(x = kLineType,
		        times = length(x = SI.h100.yield.class.values[["yield.class"]])))
        legend.lwd <- c(legend.lwd,
		    rep(x = kLineWidth,
		        times = length(x = SI.h100.yield.class.values[["yield.class"]])))
        ## Set position of legend, depending on species.
        if (cur.species.name == "beech") {
	  legend.x <- "topleft"
        }
        if (cur.species.name == "spruce") {
	  legend.x <- "bottomright"
        }
        ## Add legend.
        legend(x = legend.x,
	     ncol = kLegendNcol,
	     legend = legend.legend,
	     col = legend.col,
	     pch = legend.pch,
	     lty = legend.lty,
	     lwd = legend.lwd,
	     bg = kLegendBg)
        ## Reset legend components.
        legend.legend <- vector(mode = "character")
        legend.pch <- vector(mode = "numeric")
        legend.lty <- vector(mode = "character")
        legend.lwd <- vector(mode = "numeric")
        legend.col <- vector(mode = "character")
    }
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.                                   
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* File local variables
  # Local Variables:
  # End:
