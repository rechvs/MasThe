#+STARTUP: hideblocks
* Preamble
  #+NAME: Preamble
  #+BEGIN_SRC R :results silent :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Thesis/MasAr_Thesis.tex
    rm(list = ls())
    setwd(dir = "~/laptop02_MasAr")
    kDataDir <- "Data/"
    ## Load data set.
    kBaseFileVersion <- "5.3"
    kBaseFileName <- paste0(kDataDir, "gmax_merged_", kBaseFileVersion, ".RData")
    kgmaxObjects <- load(file = kBaseFileName, verbose = TRUE)
    ## Set dimensions of PDF device.
    kPtToCm <- 0.035146
    kPdfWidthSlide <- 358.50484 * kPtToCm  ## Use "\the\textwidth" in LaTeX document to find out total text width.
    kPdfHeightSlide <- 233.49104 * kPtToCm  ## Use "\the\textheight" in LaTeX document to find out total text height.
    ## Set point size for PDF device.
    kPdfPointSize <- 9
    ## Set font family for PDF device.
    kPdfFamily <- "Helvetica"
    ## Set standard point character for plots.
    kPointCharacter <- 20
    ## Set standard line settings for plots.
    kLineWidth <- 1
    kLineType <- "solid"
    ## Set a distinct color for each species to use in all multi-species plots. Colors are taken from NiedersÃ¤chsische Landesforsten (2011), fig. 3.
    kSpeciesColors <- list("beech" = "#ee7f00",
		       "spruce" = "#4066aa")
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set plot grid properties.
    kGridLineType <- "dashed"
    kGridLineCol <- "gray"
    kGridLineWidth <- 0.5
    ## Set background color for plot legends.
    kLegendBg <- "gray"
    ## Set vectors of species names.
    kSpeciesNames <- c("beech", "spruce")
    kSpeciesNamesCapitalized <- c("Beech", "Spruce")
    ## Set destination directory for output.
    kOutputSubdir <- "R/Output/Presentation/"
    ## Set destination directory for graphics.
    kGraphicsSubdir <- "Graphics/Presentation/"
    ## If nonexistent, create all required directories.
    system2(command = "mkdir",
	  args = paste0("-p ", c(kGraphicsSubdir, kOutputSubdir)))
    objects.at.script.start <- c(ls(), "objects.at.script.start")  ## Required for cleaning up workspace.
  #+END_SRC
* logDlogNPlotsBeforeAfterDataSelectionBeech.pdf
  #+NAME: logDlogNPlotsBeforeAfterDataSelectionBeech.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Presentation/DataSelection.tex
    ## This script creates 2 plots in one file in a 1-by-2 layout (one row per species, one column per data selection state), showing the effect of the data selection mechanism.
    ## Plotting preamble.
    kPlotMargins <- c(3.5, 3.5, 1, 1)
    kPlotMgp <- c(2, 1, 0)
    kXLab <- expression(paste("log(", italic("D"), ")"))
    kYLab <- expression(paste("log(", italic("N"), ")"))
    kXMin <- list("beech" = 0.8,
	        "spruce" = 0.8)
    kXMax <- list("beech" = 1.8,
	        "spruce" = 1.8)
    kYMin <- list("beech" = 1.6,
	        "spruce" = 2.4 * 0.9)
    kYMax <- list("beech" = 3.6,
	        "spruce" = 3.6)
    kPlotLayout <- 1:2
    kUpperThresholdLineType <- "dashed"
    kLowerThresholdLineType <- "solid"
    kThresholdLinesFrom <- 0
    kThresholdLinesTo <- 10
    kThresholdLinesCol <- "black"
    ## Loop over all species names.
    for (cur.species.name in "beech") {
        ## Turn off graphics device.
        graphics.off()
        ## Create file name.
        file.name <-paste0(kGraphicsSubdir,
		       "logDlogNPlotsBeforeAfterDataSelectionBeech.pdf")
        ## Start graphics device driver for producing PDF graphics.
        pdf(file = file.name,
	  width = kPdfWidthSlide / 2,
	  height = kPdfHeightSlide / 2 * 0.9,
	  pointsize = kPdfPointSize,
	  family = kPdfFamily)
        ## Set plot margins.
        par("mar" = kPlotMargins)
        ## Set plot layout to 1-by-2.
        layout(mat = matrix(data = kPlotLayout,
		        nrow = 1,
		        ncol = 2,
		        byrow = TRUE))
        ## Loop over all plot numbers.
        for (cur.plot.nr in kPlotLayout) {
	  ## Extract x- and y-limits for current species.
	  cur.xmin <- as.numeric(x = kXMin[names(x = kXMin) == cur.species.name])
	  cur.xmax <- as.numeric(x = kXMax[names(x = kXMax) == cur.species.name])
	  cur.ymin <- as.numeric(x = kYMin[names(x = kYMin) == cur.species.name])
	  cur.ymax <- as.numeric(x = kYMax[names(x = kYMax) == cur.species.name])
	  ## Set point and line color for current species.
	  cur.point.line.col <- as.character(x = kSpeciesColors[names(x = kSpeciesColors) == cur.species.name])
	  ## Set data frame version for current plot number ("1.0" for plots number 1 and 3, "1.8" for plots number 2 and 4).
	  cur.data.frame.version <- ifelse(test = cur.plot.nr %% 2 != 0,
				     yes = "1.0",
				     no = "1.8")
	  ## Get data frame for current species and plot number.
	  cur.data.frame <- get(x = paste0("bart.", cur.species.name, ".clean.", cur.data.frame.version))
	  ## Select column specifier for current plot ("A" for plot number 1, "B" for plot number 2, "" for plots number 3 and 4).
	  if (cur.plot.nr <=2) {
	      cur.plot.main <- ifelse(test = cur.plot.nr %% 2 != 0,
				yes = "A",
				no = "B")
	  } else {
	      cur.plot.main <- ""
	  }
	  ## Set x-axis label for current plot ("" for plots number 1 and 2, kXLab for plots number 3 and 4).
	  cur.xlab <- ifelse(test = cur.plot.nr <= 2,
			 yes = "",
			 no = kXLab)
	  ## Set y-axis label for current plot (kYLab for plots number 1 and 3, "" for plots number 2 and 4).
	  cur.ylab <- ifelse(test = cur.plot.nr %% 2 != 0,
			 yes = kYLab,
			 no = "")
	  ## Initiate legend components.
	  legend.legend <- vector(mode = "character")
	  legend.pch <- vector(mode = "numeric")
	  legend.lty <- vector(mode = "character")
	  legend.lwd <- vector(mode = "numeric")
	  legend.col <- vector(mode = "character")
	  ## Create empty plot.
	  plot(x = 0,
	       type = "n",
	       xlim = c(cur.xmin, cur.xmax),
	       ylim = c(cur.ymin, cur.ymax),
	       xlab = kXLab,
	       ## xlab = cur.xlab,
	       ## ylab = kYLab,
	       ylab = cur.ylab,
	       xaxs = "i",
	       yaxs = "i",
	       mgp = kPlotMgp,
	       main = cur.plot.main,
	       panel.first = abline(v = seq(from = 0,
				      to = 2,
				      by = 0.2),
			        h = seq(from = 0,
				      to = 4,
				      by = 0.2),
			        lty = kGridLineType,
			        lwd = kGridLineWidth,
			        col = kGridLineCol))
	  ## Define function for calculating the lines representing the slope thresholds.
	  slope.threshold.func <- function(s, x, k) {
	      res <- s * x + k
	      return(res)
	  }
	  ## Add line for upper slope threshold to plot.
	  cur.species.upper.slope.threshold <- ifelse(test = cur.species.name == "beech",
					      yes = -0.9,
					      no = -0.65)
	  cur.species.threshold.func.upper.intercept <- cur.ymax - cur.species.upper.slope.threshold * cur.xmin
	  curve(expr = slope.threshold.func(s = cur.species.upper.slope.threshold,
				      x,
				      k = cur.species.threshold.func.upper.intercept),
	        from = kThresholdLinesFrom,
	        to = kThresholdLinesTo,
	        lty = kUpperThresholdLineType,
	        lwd = kLineWidth,
	        col = kThresholdLinesCol,
	        add = TRUE)
	  ## Update legend components.
	  legend.legend <- c(legend.legend, expression(italic("m")[o]))
	  legend.pch <- c(legend.pch, NA)
	  legend.lty <- c(legend.lty, kUpperThresholdLineType)
	  legend.lwd <- c(legend.lwd, kLineWidth)
	  legend.col <- c(legend.col, kThresholdLinesCol)
	  ## Add line for lower slope threshold to plot.
	  cur.species.lower.slope.threshold <- ifelse(test = cur.species.name == "beech",
					      yes = -2.91,
					      no = -2.82)
	  cur.species.threshold.func.lower.intercept <- cur.ymax - cur.species.lower.slope.threshold * cur.xmin
	  curve(expr = slope.threshold.func(s = cur.species.lower.slope.threshold,
				      x,
				      k = cur.species.threshold.func.lower.intercept),
	        from = kThresholdLinesFrom,
	        to = kThresholdLinesTo,
	        lty = kLowerThresholdLineType,
	        lwd = kLineWidth,
	        col = kThresholdLinesCol,
	        add = TRUE)
	  ## Update legend components.
	  legend.legend <- c(legend.legend, expression(italic("m")[u]))
	  legend.pch <- c(legend.pch, NA)
	  legend.lty <- c(legend.lty, kLowerThresholdLineType)
	  legend.lwd <- c(legend.lwd, kLineWidth)
	  legend.col <- c(legend.col, kThresholdLinesCol)
	  ## Loop over all "edvid"s.
	  for (cur.edvid.name in levels(x = cur.data.frame[["edvid"]])) {
	      ## Extract x-values for current "edvid".
	      cur.x.values <- cur.data.frame[["log.dg"]][cur.data.frame[["edvid"]] == cur.edvid.name]
	      ## Extract y-values for current "edvid".
	      cur.y.values <- cur.data.frame[["log.nha"]][cur.data.frame[["edvid"]] == cur.edvid.name]
	      ## Add points to plot per "edvid", with distinct colors per species.
	      points(x = cur.x.values,
		   y = cur.y.values,
		   type = "p",
		   pch = kPointCharacter,
		   lty = kLineType,
		   col = cur.point.line.col)
	      ## Add lines to plot per "edvid", with distinct colors per species.
	      lines(x = cur.x.values,
		  y = cur.y.values,
		  lty = kLineType,
		  lwd = kLineWidth,
		  col = cur.point.line.col)
	  }
	  ## Calculate number of observations in current data frame.
	  cur.n <- nrow(x = cur.data.frame)
	  ## Update legend components.
	  ## legend.legend <- c(legend.legend, paste0("Beobachtungen (n = ", cur.n, ")"))
	  legend.legend <- c(legend.legend,
			 mapply(FUN = function(expr, numbr) { as.expression(x = bquote(.(expr)*.(numbr)*")")) },  ## See https://stackoverflow.com/questions/27275798/combining-vector-variables-in-r-expression-for-plot-text?noredirect=1.
			        expr = expression("Beobachtungen ("*italic("n")*" = "),
			        numbr = cur.n))
	  legend.pch <- c(legend.pch, kPointCharacter)
	  legend.lty <- c(legend.lty, kLineType)
	  legend.lwd <- c(legend.lwd, kLineWidth)
	  legend.col <- c(legend.col, cur.point.line.col)
	  ## Add legend.
	  legend(x = "bottomleft",
	         legend = legend.legend,
	         col = legend.col,
	         lty = legend.lty,
	         pch = legend.pch,
	         lwd = legend.lwd,
	         bg = "gray")
	  ## Reset legend components.
	  legend.legend <- vector(mode = "character")
	  legend.pch <- vector(mode = "numeric")
	  legend.lty <- vector(mode = "character")
	  legend.lwd <- vector(mode = "numeric")
	  legend.col <- vector(mode = "character")
        }
        ## Turn off graphics device.
        graphics.off()
    }
    ## Clean up workspace.
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* AgeBasalAreaObservationsGAM2PredictionsBeech.pdf
  #+NAME: AgeBasalAreaObservationsGAM2PredictionsBeech.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Presentation/Modelling.tex
    ## Plotting preamble ##
    #######################
    kPlotMargins <- c(3, 3.25, 2, 1)
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- 1
    kLegendX <- "bottomleft"
    kLegendNcol <- 3
    kXLim <- c(30, 160)
    kYLim <- c(0, 60)
    ## Create file name.
    kFilename <-paste0(kGraphicsSubdir,
		   "AgeBasalAreaObservationsGAM2PredictionsBeech.pdf")
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Initiate legend components.
    legend.legend <- vector(mode = "character")
    legend.pch <- vector(mode = "numeric")
    legend.lty <- vector(mode = "character")
    legend.lwd <- vector(mode = "numeric")
    legend.col <- vector(mode = "character")
    ## Modelling preamble ##
    ########################
    kFormula <- as.formula(object = "gha ~ s(h100.EKL.I) + SI.h100.diff.EKL.I")
    ## Fit model ##
    ###############
    cur.model <- mgcv::gam(formula = kFormula,
		       data = bart.beech.clean.1.8,
		       family = Gamma(link = "log"),
		       na.action = na.omit)
    ## Plot observations ##
    #######################
    ## Turn off graphics device.
    graphics.off()
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = kFilename,
        width = kPdfWidthSlide / 2,
        height = kPdfHeightSlide / 2 * 0.9,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
    SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				     "SI.h100" = NA)
    ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
    SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
    SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
    SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
    SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
    ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
    for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
        SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
        SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
        SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
    }
    ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
    SI.h100.min <- min(bart.beech.clean.1.8[["SI.h100"]],
		   na.rm = TRUE)
    SI.h100.max <- max(bart.beech.clean.1.8[["SI.h100"]],
		   na.rm = TRUE)
    index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
    index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
    ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
    SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
			        to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
			        by = 0.1),
			digits = 1)
    ## Generate a color palette of the same length as "SI.h100.sequence".
    cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
    ## Set plot margins.
    par("mar" = kPlotMargins)
    ## Create empty plot.
    plot(x = bart.beech.clean.1.8[["alt"]],
         type = "n",
         xlim = kXLim,
         ylim = kYLim,
         xlab = "Alter [a]",
         ylab = expression(italic("G")*" ["*m^2*" ha"^-1*"]"),
         main = "GAM",
         mgp = kPlotMgp,
         xaxs = "i",
         yaxs = "i",
         panel.first = abline(v = seq(from = kXLim[1],
			        to = kXLim[2],
			        by = 10),
			h  = seq(from = kYLim[1],
			         to = kYLim[2],
			         by = 10),
			lty = kGridLineType,
			lwd = kGridLineWidth,
			col = kGridLineCol))
    ## Loop over all evdids.
    for (cur.edvid in levels(x = bart.beech.clean.1.8[["edvid"]])) {
        ## Create subset of "bart.beech.clean.1.8", based on current edvid.
        edvid.subset <- subset(x = bart.beech.clean.1.8,
			 subset = edvid == cur.edvid)
        ## Add lines for observations belonging to current edvid.
        lines(x =edvid.subset[["alt"]],
	    y = edvid.subset[["gha"]],
	    lwd = kLineWidth,
	    lty = kLineType)
    }
    ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
    for (cur.edvid in levels(x = bart.beech.clean.1.8[["edvid"]])) {
        ## Create subset of "bart.beech.clean.1.8", based on current edvid.
        edvid.subset <- subset(x = bart.beech.clean.1.8,
			 subset = edvid == cur.edvid)
        ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
        SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				     table = SI.h100.sequence)
        ## Add points to plot.
        points(x = edvid.subset[["alt"]],
	     y = edvid.subset[["gha"]],
	     col = cur.species.color.palette[SI.h100.rounded.color.index],
	     pch = kPointCharacter)
    }
    ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
    SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						  digits = 1),
					  table = SI.h100.sequence)
    ## Update legend components.
    legend.legend <- c(legend.legend,
		   paste0("Beobachtung EKL ",
			SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
    legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
    legend.pch <- c(legend.pch, rep(x = kPointCharacter, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
    legend.lty <- c(legend.lty, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
    legend.lwd <- c(legend.lwd, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
    ## Add model predictions to plot ##
    ###################################
    ## Get test data for current species.
    new.data <- nagel.beech
    ## Cap test data frame based on column "age" in order to avoid extrapolation of models beyond the range of the training data.
    new.data <- subset(x = new.data,
		   subset = age >= 35 & age <= 155)
    ## Calculate model predictions.
    new.data[["gha.predictions"]] <- mgcv::predict.gam(object = cur.model,
					     newdata = new.data,
					     type = "response")
    ## Add lines to plot per yield class.
    all.cols <- rev(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])
    for (cur.yield.class.index in rev(x = seq_len(length.out = length(x = levels(x = new.data[["yield.class"]]))))) {
        yield.class.name <- levels(x = new.data[["yield.class"]])[cur.yield.class.index]
        line.col <- all.cols[cur.yield.class.index]
        lines(x = new.data[["age"]][new.data[["yield.class"]] == yield.class.name],
	    y = new.data[["gha.predictions"]][new.data[["yield.class"]] == yield.class.name],
	    col = line.col,
	    lty = kLineType,
	    lwd = kLineWidth)
        ## Update legend components.
        legend.legend <- c(legend.legend,
		       paste0("Vorhersage EKL ",
			    yield.class.name))
        legend.pch <- c(legend.pch, NA)
        legend.lty <- c(legend.lty, kLineType)
        legend.lwd <- c(legend.lwd, kLineWidth)
        legend.col <- c(legend.col, line.col)
    }
    ## Add legend.
    legend(x = kLegendX,
	 ncol = kLegendNcol,
	 legend = legend.legend,
	 col = legend.col,
	 pch = legend.pch,
	 lty = legend.lty,
	 lwd = legend.lwd,
	 bg = kLegendBg)
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.                                   
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* TopHeightBasalAreaObservationsGAM2PredictionsBeech.pdf
  #+NAME: TopHeightBasalAreaObservationsGAM2PredictionsBeech.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Presentation/Modelling.tex
    ## Plotting preamble ##
    #######################
    kPlotMargins <- c(3, 3.25, 2, 1)
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- 1
    kLegendX <- "bottomleft"
    kLegendNcol <- 3
    kXLim <- c(10, 50)
    kYLim <- c(-10, 60)
    ## Create file name.
    kFilename <-paste0(kGraphicsSubdir,
		   "TopHeightBasalAreaObservationsGAM2PredictionsBeech.pdf")
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Initiate legend components.
    legend.legend <- vector(mode = "character")
    legend.pch <- vector(mode = "numeric")
    legend.lty <- vector(mode = "character")
    legend.lwd <- vector(mode = "numeric")
    legend.col <- vector(mode = "character")
    ## Modelling preamble ##
    ########################
    kFormula <- as.formula(object = "gha ~ s(h100.EKL.I) + SI.h100.diff.EKL.I")
    ## Fit model ##
    ###############
    cur.model <- mgcv::gam(formula = kFormula,
		       data = bart.beech.clean.1.8,
		       family = Gamma(link = "log"),
		       na.action = na.omit)
    ## Plot observations ##
    #######################
    ## Turn off graphics device.
    graphics.off()
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = kFilename,
        width = kPdfWidthSlide / 2,
        height = kPdfHeightSlide / 2 * 0.9,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
    SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				     "SI.h100" = NA)
    ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
    SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
    SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
    SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
    SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
    ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
    for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
        SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
        SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
        SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
    }
    ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
    SI.h100.min <- min(bart.beech.clean.1.8[["SI.h100"]],
		   na.rm = TRUE)
    SI.h100.max <- max(bart.beech.clean.1.8[["SI.h100"]],
		   na.rm = TRUE)
    index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
    index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
    ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
    SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
			        to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
			        by = 0.1),
			digits = 1)
    ## Generate a color palette of the same length as "SI.h100.sequence".
    cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
    ## Set plot margins.
    par("mar" = kPlotMargins)
    ## Create empty plot.
    plot(x = bart.beech.clean.1.8[["h100"]],
         type = "n",
         xlim = kXLim,
         ylim = kYLim,
         xlab = expression(italic("h")[100]*" [m]"),
         ylab = expression(italic("G")*" ["*m^2*" ha"^-1*"]"),
         main = "GAM",
         mgp = kPlotMgp,
         xaxs = "i",
         yaxs = "i",
         panel.first = abline(v = seq(from = kXLim[1],
			        to = kXLim[2],
			        by = 10),
			h  = seq(from = kYLim[1],
			         to = kYLim[2],
			         by = 10),
			lty = kGridLineType,
			lwd = kGridLineWidth,
			col = kGridLineCol))
    ## Loop over all evdids.
    for (cur.edvid in levels(x = bart.beech.clean.1.8[["edvid"]])) {
        ## Create subset of "bart.beech.clean.1.8", based on current edvid.
        edvid.subset <- subset(x = bart.beech.clean.1.8,
			 subset = edvid == cur.edvid)
        ## Add lines for observations belonging to current edvid.
        lines(x =edvid.subset[["h100"]],
	    y = edvid.subset[["gha"]],
	    lwd = kLineWidth,
	    lty = kLineType)
    }
    ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
    for (cur.edvid in levels(x = bart.beech.clean.1.8[["edvid"]])) {
        ## Create subset of "bart.beech.clean.1.8", based on current edvid.
        edvid.subset <- subset(x = bart.beech.clean.1.8,
			 subset = edvid == cur.edvid)
        ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
        SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				     table = SI.h100.sequence)
        ## Add points to plot.
        points(x = edvid.subset[["h100"]],
	     y = edvid.subset[["gha"]],
	     col = cur.species.color.palette[SI.h100.rounded.color.index],
	     pch = kPointCharacter)
    }
    ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
    SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						  digits = 1),
					  table = SI.h100.sequence)
    ## Update legend components.
    legend.legend <- c(legend.legend,
		   paste0("Beobachtung EKL ",
			SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
    legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
    legend.pch <- c(legend.pch, rep(x = kPointCharacter, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
    legend.lty <- c(legend.lty, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
    legend.lwd <- c(legend.lwd, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
    ## Add model predictions to plot ##
    ###################################
    ## Get test data for current species.
    new.data <- nagel.beech
    ## Cap test data frame based on column "h100" in order to avoid extrapolation of models beyond the range of the training data.
    new.data <- subset(x = new.data,
		   subset = h100 >= 10 & h100 <= 50)
    ## Calculate model predictions.
    new.data[["gha.predictions"]] <- mgcv::predict.gam(object = cur.model,
					     newdata = new.data,
					     type = "response")
    ## Add lines to plot per yield class.
    all.cols <- rev(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])
    for (cur.yield.class.index in rev(x = seq_len(length.out = length(x = levels(x = new.data[["yield.class"]]))))) {
        yield.class.name <- levels(x = new.data[["yield.class"]])[cur.yield.class.index]
        line.col <- all.cols[cur.yield.class.index]
        lines(x = new.data[["h100"]][new.data[["yield.class"]] == yield.class.name],
	    y = new.data[["gha.predictions"]][new.data[["yield.class"]] == yield.class.name],
	    col = line.col,
	    lty = kLineType,
	    lwd = kLineWidth)
        ## Update legend components.
        legend.legend <- c(legend.legend,
		       paste0("Vorhersage EKL ",
			    yield.class.name))
        legend.pch <- c(legend.pch, NA)
        legend.lty <- c(legend.lty, kLineType)
        legend.lwd <- c(legend.lwd, kLineWidth)
        legend.col <- c(legend.col, line.col)
    }
    ## Add legend.
    legend(x = kLegendX,
	 ncol = kLegendNcol,
	 legend = legend.legend,
	 col = legend.col,
	 pch = legend.pch,
	 lty = legend.lty,
	 lwd = legend.lwd,
	 bg = kLegendBg)
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.                                   
    ## rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
* AgeBasalAreaObservationsGAMLSS3PredictionsBeech.pdf
  #+NAME: AgeBasalAreaObservationsGAMLSS3PredictionsBeech.pdf
  #+BEGIN_SRC R :results silent :var input=Preamble :session *MasArThesisRConsole*
    ## TEX file: ~/laptop02_MasAr/LaTeX/Presentation/Modelling.tex
    ## Plotting preamble ##
    #######################
    kPlotMargins <- c(3, 3.25, 2, 1)
    kPlotMgp <- c(2, 1, 0)
    kPlotLayout <- 1
    kLegendX <- "bottomleft"
    kLegendNcol <- 3
    kXLim <- c(30, 160)
    kYLim <- c(0, 60)
    ## Create file name.
    kFilename <-paste0(kGraphicsSubdir,
		   "AgeBasalAreaObservationsGAMLSS3PredictionsBeech.pdf")
    ## Define color palette generating function.
    kColorPaletteFunc <- colorRampPalette(colors = c("red", "yellow", "springgreen", "royalblue"))
    ## Set best yield class level for which to interpolate SI.h100 values
    kBestYieldClassLevel <- -2
    ## Initiate legend components.
    legend.legend <- vector(mode = "character")
    legend.pch <- vector(mode = "numeric")
    legend.lty <- vector(mode = "character")
    legend.lwd <- vector(mode = "numeric")
    legend.col <- vector(mode = "character")
    ## Modelling preamble ##
    ########################
    library(package = "gamlss")
    kFormula <- as.formula(object = "gha ~ pbm(h100.EKL.I) + SI.h100.diff.EKL.I")
    ## Fit model ##
    ###############
    ## Subset input data frame to the variables mentioned in the model formula.
    cur.input.data.col.subset <- bart.beech.clean.1.8[, all.vars(expr = kFormula)]
    ## Remove missing values from "cur.input.data.col.subset".
    cur.input.data.col.subset.na.omitted <- na.omit(object = cur.input.data.col.subset)
    ## Fit model.
    cur.model <- gamlss::gamlss(formula = kFormula,
			  sigma.formula = "gha ~ 1",
			  nu.formula = "gha ~ 1",
			  tau.formula = "gha ~ 1",
			  family = gamlss.dist::BCCGo(),
			  data = cur.input.data.col.subset.na.omitted,
			  method = RS(1000))
    ## Plot observations ##
    #######################
    ## Turn off graphics device.
    graphics.off()
    ## Start graphics device driver for producing PDF graphics.
    pdf(file = kFilename,
        width = kPdfWidthSlide / 2,
        height = kPdfHeightSlide / 2 * 0.9,
        pointsize = kPdfPointSize,
        family = kPdfFamily)
    ## Set plot layout.
    layout(mat = kPlotLayout)
    ## Initiate data frame in which to store SI.h100 values for all yield classes (1 row per yield class).
    SI.h100.yield.class.values <- data.frame("yield.class" = seq(from = 4, to = kBestYieldClassLevel, by = -1),
				     "SI.h100" = NA)
    ## Set SI.h100 values for yield classes 4, 3, 2, and 1 based on Schober (1995) (moderate thinning).
    SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 4] <- 20.7
    SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 3] <- 24.7
    SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2] <- 28.6
    SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1] <- 32.4
    ## Interpolate SI.h100 values for yield classes 0 to "kBestYieldClassLevel" linearly from values for yield classes 2 and 1.
    for (cur.yield.class in c(seq(from = 0, to = kBestYieldClassLevel, by = -1))) {
        SI.h100.yield.class.2 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 2]
        SI.h100.yield.class.1 <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == 1]
        SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class] <- SI.h100.yield.class.values[["SI.h100"]][SI.h100.yield.class.values[["yield.class"]] == cur.yield.class + 1] + SI.h100.yield.class.1 - SI.h100.yield.class.2
    }
    ## Determine the best worst and best yield classes needed to cover the range of SI.h100 values present in the data frame.
    SI.h100.min <- min(bart.beech.clean.1.8[["SI.h100"]],
		   na.rm = TRUE)
    SI.h100.max <- max(bart.beech.clean.1.8[["SI.h100"]],
		   na.rm = TRUE)
    index.worst.yield.class.needed <- max(which(x = SI.h100.yield.class.values[["SI.h100"]] < SI.h100.min))
    index.best.yield.class.needed <- min(which(x = SI.h100.yield.class.values[["SI.h100"]] > SI.h100.max))
    ## Generate a sequence ranging from SI.h100 of worst to SI.h100 of best yield classes needed, with 0.1 as the distance between sequence elements. The sequence is rounded to allow seamless comparison with other rounded numbers.
    SI.h100.sequence <- round(x = seq(from = SI.h100.yield.class.values[index.worst.yield.class.needed, "SI.h100"],
			        to = SI.h100.yield.class.values[index.best.yield.class.needed, "SI.h100"],
			        by = 0.1),
			digits = 1)
    ## Generate a color palette of the same length as "SI.h100.sequence".
    cur.species.color.palette <- kColorPaletteFunc(n = length(x = SI.h100.sequence))
    ## Set plot margins.
    par("mar" = kPlotMargins)
    ## Create empty plot.
    plot(x = bart.beech.clean.1.8[["alt"]],
         type = "n",
         xlim = kXLim,
         ylim = kYLim,
         xlab = "Alter [a]",
         ylab = expression(italic("G")*" ["*m^2*" ha"^-1*"]"),
         main = "GAM",
         mgp = kPlotMgp,
         xaxs = "i",
         yaxs = "i",
         panel.first = abline(v = seq(from = kXLim[1],
			        to = kXLim[2],
			        by = 10),
			h  = seq(from = kYLim[1],
			         to = kYLim[2],
			         by = 10),
			lty = kGridLineType,
			lwd = kGridLineWidth,
			col = kGridLineCol))
    ## Loop over all evdids.
    for (cur.edvid in levels(x = bart.beech.clean.1.8[["edvid"]])) {
        ## Create subset of "bart.beech.clean.1.8", based on current edvid.
        edvid.subset <- subset(x = bart.beech.clean.1.8,
			 subset = edvid == cur.edvid)
        ## Add lines for observations belonging to current edvid.
        lines(x =edvid.subset[["alt"]],
	    y = edvid.subset[["gha"]],
	    lwd = kLineWidth,
	    lty = kLineType)
    }
    ## Loop over all evdids. We use a second loop here in order to make sure that points are drawn after all lines have been drawn.
    for (cur.edvid in levels(x = bart.beech.clean.1.8[["edvid"]])) {
        ## Create subset of "bart.beech.clean.1.8", based on current edvid.
        edvid.subset <- subset(x = bart.beech.clean.1.8,
			 subset = edvid == cur.edvid)
        ## Map each element of column "SI.h100" to an index in "SI.h100.sequence". Column "SI.h100" is rounded to 1 decimal digit in order to allow comparison with "SI.h100.sequence".
        SI.h100.rounded.color.index <- match(x = round(x = edvid.subset[["SI.h100"]], digits = 1),
				     table = SI.h100.sequence)
        ## Add points to plot.
        points(x = edvid.subset[["alt"]],
	     y = edvid.subset[["gha"]],
	     col = cur.species.color.palette[SI.h100.rounded.color.index],
	     pch = kPointCharacter)
    }
    ## Map the central SI.h100 value of each yield class to an index in "SI.h100.sequence".
    SI.h100.yield.class.values.color.index <- match(x = round(x = SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "SI.h100"],
						  digits = 1),
					  table = SI.h100.sequence)
    ## Update legend components.
    legend.legend <- c(legend.legend,
		   paste0("Beobachtung EKL ",
			SI.h100.yield.class.values[index.worst.yield.class.needed : index.best.yield.class.needed, "yield.class"]))
    legend.col <- c(legend.col, cur.species.color.palette[SI.h100.yield.class.values.color.index])
    legend.pch <- c(legend.pch, rep(x = kPointCharacter, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
    legend.lty <- c(legend.lty, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
    legend.lwd <- c(legend.lwd, rep(x = NA, times = length(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])))
    ## Add model predictions to plot ##
    ###################################
    ## Get test data for current species.
    cur.nagel <- nagel.beech
    new.data <- cur.nagel
    ## Cap test data frame based on column "age" in order to avoid extrapolation of models beyond the range of the training data.
    new.data <- subset(x = new.data,
		   subset = age >= 35 & age <= 155)
    cur.nagel <- subset(x = cur.nagel,
		   subset = age >= 35 & age <= 155)
    ## Restrict "new.data" to the columns of the independent variables of the current model.
    new.data <- subset(x = new.data,
		   select = all.vars(kFormula)[-1])
    ## Calculate model predictions.
    new.data[["gha.predictions"]] <- predict(object = cur.model,
				     newdata = new.data,
				     what = "mu",
				     type = "response")
    ## Reattach columns "age", "h100", and "yield.class" to "new.data".
    new.data[["age"]] <- na.omit(object = cur.nagel)[["age"]]
    new.data[["h100"]] <- na.omit(object = cur.nagel)[["h100"]]
    new.data[["yield.class"]] <- na.omit(object = cur.nagel)[["yield.class"]]
    ## Add lines to plot per yield class.
    all.cols <- rev(x = cur.species.color.palette[SI.h100.yield.class.values.color.index])
    for (cur.yield.class.index in rev(x = seq_len(length.out = length(x = levels(x = new.data[["yield.class"]]))))) {
        yield.class.name <- levels(x = new.data[["yield.class"]])[cur.yield.class.index]
        line.col <- all.cols[cur.yield.class.index]
        lines(x = new.data[["age"]][new.data[["yield.class"]] == yield.class.name],
	    y = new.data[["gha.predictions"]][new.data[["yield.class"]] == yield.class.name],
	    col = line.col,
	    lty = kLineType,
	    lwd = kLineWidth)
        ## Update legend components.
        legend.legend <- c(legend.legend,
		       paste0("Vorhersage EKL ",
			    yield.class.name))
        legend.pch <- c(legend.pch, NA)
        legend.lty <- c(legend.lty, kLineType)
        legend.lwd <- c(legend.lwd, kLineWidth)
        legend.col <- c(legend.col, line.col)
    }
    ## Add legend.
    legend(x = kLegendX,
	 ncol = kLegendNcol,
	 legend = legend.legend,
	 col = legend.col,
	 pch = legend.pch,
	 lty = legend.lty,
	 lwd = legend.lwd,
	 bg = kLegendBg)
    ## Turn off graphics device.
    graphics.off()
    ## Clean up workspace.                                   
    rm(list = setdiff(x = ls(), y = objects.at.script.start))
  #+END_SRC
